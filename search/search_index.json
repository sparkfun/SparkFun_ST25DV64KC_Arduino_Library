{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SparkFun ST25DV64KC Arduino Library","text":"SparkFun Qwiic Dynamic RFID Tag - ST25DV64KC (SPX-19035) <p>An Arduino library for the ST25DV64KC Dynamic NFC/RFID Tag.</p> <p>With this library, you can:</p> <ul> <li>Write WiFi credentials to the tag using your smart phone and then have your Arduino board read them via I2C</li> <li>Log data from your Arduino project into the tag's EEPROM memory and then read it back with your smart phone - even while your Arduino board is asleep or powered off!</li> <li>Configure or update your project's keys, usernames or passwords securely and easily using contactless near field communication</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Provides a comprehensive set of methods to:<ul> <li>Read and write the tag's user memory</li> <li>Adjust the size of the four memory areas</li> <li>Change the I2C and RF passwords and read/write protection</li> <li>Enable RF detection and Energy Harvesting</li> </ul> </li> <li>Includes enhanced methods to:<ul> <li>Write the tag's Capability Container (CC) File</li> <li>Read and write multiple NDEF URI records</li> <li>Read and write multiple NDEF WiFi records</li> <li>Read and write multiple NDEF Text records</li> </ul> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>The Getting Started Page outlines library installation and the general use of the SparkFun ST25DV64KC Arduino Library. </p> <p>Detailed <code>examples</code> are included as part of the library installation process and available in the Arduino IDE <code>File &gt; Examples &gt;</code> menu. A walk-thru of key examples is contained in the Examples section of this documentation set. </p> <p>A full API Reference is also provided for the library.</p>"},{"location":"#tested-platforms","title":"Tested Platforms","text":"<ul> <li>ATmega328P</li> <li>ESP32</li> <li>Artemis (Apollo3)</li> <li>SAMD21</li> <li>SAMD51</li> <li>STM32</li> <li>RP2040 following the instructions in the Hookup Guide and using the pin definitions shown below:</li> </ul> <pre><code>// pins_arduino.h : pin definitions for the RP2040 Thing Plus (DEV-17745)\n// SPI\n#define PIN_SPI_MISO  (12u)\n#define PIN_SPI_MOSI  (15u)\n#define PIN_SPI_SCK   (14u)\n#define PIN_SPI_SS    (9u)\n// Wire\n#define PIN_WIRE_SDA  (6u)\n#define PIN_WIRE_SCL  (7u)\n</code></pre>"},{"location":"#license","title":"License","text":"<p>The SparkFun ST25DV64KC Arduino Library is licensed using the Open Source MIT License</p>"},{"location":"api_SFE_ST25DV64KC/","title":"API Reference for the SFE_ST25DV64KC class","text":""},{"location":"api_SFE_ST25DV64KC/#brief-overview","title":"Brief Overview","text":"<p>The <code>SFE_ST25DV64KC</code> class provides all of the necessary methods to exchange data with the ST25DV tag.</p> <p>Communication with the tag is started by calling <code>begin</code> and providing the address of a <code>TwoWire</code> (I<sup>2</sup>C) Port. <code>begin</code> will default to <code>Wire</code> if no <code>wirePort</code> is provided.</p> <p>The tag's unique identifier (UID) can be read with <code>getDeviceUID</code>. The hardware version can be checked with <code>getDeviceRevision</code>.</p> <p>By default, the user memory can be both read and written to via both I<sup>2</sup>C and RF (NFC). But, to change any of the IC's settings, a security session needs to be opened by entering the correct password. The default password is eight zeros ( 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ) and - for I<sup>2</sup>C - can be entered by calling <code>openI2CSession</code>. The status of the security session can be checked with <code>isI2CSessionOpen</code>. The I<sup>2</sup>C password can be changed with <code>writeI2CPassword</code>.</p> <p>Attention</p> <p>The password can be read back from the tag with <code>readRegisterValues</code>, but only when a security session is open. If you change the password, close the security session and then forget the password, your tag is locked forever. There is no way to change or reset the pasword unless you know the password. If you change it, write it down somewhere.</p> <p>The memory can be divided up into four areas, each of which can have different security levels applied. <code>setMemoryAreaEndAddress</code> and <code>getMemoryAreaEndAddress</code> can change and read the end address for each area.</p> <p>With an open security session, the I<sup>2</sup>C read and write permissions for each area can be changed and read with <code>programEEPROMReadProtectionBit</code>, <code>programEEPROMWriteProtectionBit</code>, <code>getEEPROMReadProtectionBit</code> and <code>getEEPROMWriteProtectionBit</code>.</p> <p>With an open security session, the RF read and write permissions for each area can be changed and read with <code>setAreaRfRwProtection</code> and <code>getAreaRfRwProtection</code>. RF password control and be set and read with <code>setAreaRfPwdCtrl</code> and <code>getAreaRfPwdCtrl</code>.</p> <p>The EEPROM memory can be read and written with <code>readEEPROM</code> and <code>writeEEPROM</code>.</p> <p>The behaviour of the GPO pin can be set and read with <code>setGPO1Bit</code>, <code>getGPO1Bit</code>, <code>setGPO2Bit</code> and <code>getGPO2Bit</code>.</p> <p>Energy harvesting can be controlled with <code>setEH_MODEBit</code> and <code>getEH_MODEBit</code>.</p>"},{"location":"api_SFE_ST25DV64KC/#initialization-configuration","title":"Initialization / Configuration","text":""},{"location":"api_SFE_ST25DV64KC/#seterrorcallback","title":"setErrorCallback()","text":"<p>This method sets the address of the error callback. Once set, a callback is triggered if an error occurs within a method.</p> <pre><code>void setErrorCallback(void (*errorCallback)(SF_ST25DV64KC_ERROR errorCode))\n</code></pre> <p>An example error handler - if <code>tag</code> is global - is:</p> <pre><code>void errorHandler(SF_ST25DV64KC_ERROR errorCode)\n{\n    Serial.print(F(\"Error Callback: \"));\n    Serial.println(tag.errorCodeString(errorCode));\n}\n</code></pre> <p><code>errorCodeString</code> converts the <code>SF_ST25DV64KC_ERROR</code> enum into readable text.</p> <p>The callback is set with:</p> <pre><code>tag.setErrorCallback(&amp;errorHandler);\n</code></pre> Parameter Description <code>errorCallback</code> The address of the callback"},{"location":"api_SFE_ST25DV64KC/#begin","title":"begin()","text":"<p>This method configures I<sup>2</sup>C communication with the tag and confirms the tag is connected.</p> <pre><code>bool begin(TwoWire &amp;wirePort)\n</code></pre> Parameter Type Description <code>wirePort</code> <code>TwoWire &amp;</code> The address of the TwoWire port. Default is <code>Wire</code> return value <code>bool</code> <code>true</code> if communication is begun successfully, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#isconnected","title":"isConnected()","text":"<p>This method confirms if a device is connected at the expected I<sup>2</sup>C address. This method can only be called after <code>begin</code>, as <code>begin</code> configures which TwoWire port will be used. <code>begin</code> calls <code>isConnected</code> internally to establish if a tag is connected.</p> <pre><code>bool isConnected()\n</code></pre> Parameter Type Description return value <code>bool</code> <code>true</code> if the tag is connected, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#device-properties","title":"Device Properties","text":""},{"location":"api_SFE_ST25DV64KC/#getdeviceuid","title":"getDeviceUID()","text":"<p>This method reads the tag's 64-bit unique identifier as uint8_t[8].</p> <pre><code>bool getDeviceUID(uint8_t *values)\n</code></pre> Parameter Type Description <code>values</code> <code>uint8_t *</code> A pointer to the array of uint8_t that will contain the UID. <code>values</code> must be uint8_t[8] return value <code>bool</code> <code>true</code> if the read is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#getdevicerevision","title":"getDeviceRevision()","text":"<p>This method reads the tag's hardware revision.</p> <pre><code>bool getDeviceRevision(uint8_t *value)\n</code></pre> Parameter Type Description <code>value</code> <code>uint8_t *</code> A pointer to uint8_t that will contain the revision return value <code>bool</code> <code>true</code> if the read is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#security-session-password-control","title":"Security Session Password Control","text":""},{"location":"api_SFE_ST25DV64KC/#openi2csession","title":"openI2CSession()","text":"<p>This method enters the I<sup>2</sup>C security session 64-bit password. password is uint8_t[8]. This method returns <code>true</code> if the password is written to the tag successfully - but that does not confirm that the password is valid/invalid. The password validity must be confirmed with <code>isI2CSessionOpen</code>.</p> <pre><code>bool openI2CSession(uint8_t *password)\n</code></pre> Parameter Type Description <code>password</code> <code>uint8_t *</code> A pointer to the array of uint8_t that contains the password. password must be uint8_t[8] return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#isi2csessionopen","title":"isI2CSessionOpen()","text":"<p>This method checks if the I<sup>2</sup>C security session is open, i.e. that the correct password has been entered.</p> <pre><code>bool isI2CSessionOpen()\n</code></pre> Parameter Type Description return value <code>bool</code> <code>true</code> if the security session is open, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#writei2cpassword","title":"writeI2CPassword()","text":"<p>This method changes the I<sup>2</sup>C password. It will only be successful when a security session is open, i.e. you need to know the current password to be able to change the password (obvs.).</p> <p>Attention</p> <p>The password can be read back from the tag with <code>readRegisterValues</code>, but only when a security session is open. If you change the password, close the security session and then forget the password, your tag is locked forever. There is no way to change or reset the pasword unless you know the password. If you change it, write it down somewhere.</p> <pre><code>bool writeI2CPassword(uint8_t *password)\n</code></pre> Parameter Type Description <code>password</code> <code>uint8_t *</code> A pointer to the array of uint8_t that contains the new password. password must be uint8_t[8] return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#memory-area-control","title":"Memory Area Control","text":""},{"location":"api_SFE_ST25DV64KC/#setmemoryareaendaddress","title":"setMemoryAreaEndAddress()","text":"<p>This method is used to modify the end address for memory Areas 1-3. The end address of Area 4 is always set to the tag's last memory location.</p> <p><code>endAddressValue</code> is an 8-bit value. The actual memory end address is: (32 * <code>endAddressValue</code>) + 31</p> <pre><code>bool setMemoryAreaEndAddress(uint8_t memoryNumber, uint8_t endAddressValue)\n</code></pre> Parameter Type Description <code>memoryNumber</code> <code>uint8_t</code> The memory area 1-3 <code>endAddressValue</code> <code>uint8_t</code> The end address in 8-bit form. See notes above return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#getmemoryareaendaddress","title":"getMemoryAreaEndAddress()","text":"<p>This method returns the end address for the specified area.</p> <p>If a read error occurs, an error callback is triggered.</p> <p>The returned address is the actual end address in 16-bit format, not the 8-bit register value used by <code>setMemoryAreaEndAddress</code>.</p> <pre><code>uint16_t getMemoryAreaEndAddress(uint8_t memoryArea)\n</code></pre> Parameter Type Description <code>memoryArea</code> <code>uint8_t</code> The memory area 1-3 return value <code>uint16_t</code> The actual end address (16-bit)"},{"location":"api_SFE_ST25DV64KC/#i2c-read-and-write-protection","title":"I<sup>2</sup>C Read and Write Protection","text":""},{"location":"api_SFE_ST25DV64KC/#programeepromreadprotectionbit","title":"programEEPROMReadProtectionBit()","text":"<p>This method sets/clears the I<sup>2</sup>C read protection bit for the specified memory area 1-4.</p> <p>When set, the memory area is only readable if a security session is open.</p> <p>Note</p> <p>Area 1 is always readable. Calling <code>programEEPROMReadProtectionBit(1, true)</code> has no effect.</p> <pre><code>bool programEEPROMReadProtectionBit(uint8_t memoryArea, bool readSecured)\n</code></pre> Parameter Type Description <code>memoryArea</code> <code>uint8_t</code> The memory area 1-4 <code>readSecured</code> <code>bool</code> <code>true</code>: read is allowed only if an I<sup>2</sup>C security session is open. <code>false</code>: read is always allowed return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#programeepromwriteprotectionbit","title":"programEEPROMWriteProtectionBit()","text":"<p>This method sets/clears the I<sup>2</sup>C write protection bit for the specified memory area 1-4.</p> <p>When set, the memory area is only writeable if a security session is open.</p> <pre><code>bool programEEPROMWriteProtectionBit(uint8_t memoryArea, bool writeSecured)\n</code></pre> Parameter Type Description <code>memoryArea</code> <code>uint8_t</code> The memory area 1-4 <code>writeSecured</code> <code>bool</code> <code>true</code>: write is allowed only if an I<sup>2</sup>C security session is open. <code>false</code>: write is always allowed return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#geteepromreadprotectionbit","title":"getEEPROMReadProtectionBit()","text":"<p>This method returns the state of read protection for the specified memory area 1-4..</p> <pre><code>bool getEEPROMReadProtectionBit(uint8_t memoryArea)\n</code></pre> Parameter Type Description <code>memoryArea</code> <code>uint8_t</code> The memory area 1-4 return value <code>bool</code> <code>true</code> if memory read is protected, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#geteepromwriteprotectionbit","title":"getEEPROMWriteProtectionBit()","text":"<p>This method returns the state of write protection for the specified memory area 1-4..</p> <pre><code>bool getEEPROMWriteProtectionBit(uint8_t memoryArea)\n</code></pre> Parameter Type Description <code>memoryArea</code> <code>uint8_t</code> The memory area 1-4 return value <code>bool</code> <code>true</code> if memory write is protected, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#rf-read-and-write-protection","title":"RF Read and Write Protection","text":""},{"location":"api_SFE_ST25DV64KC/#setarearfrwprotection","title":"setAreaRfRwProtection()","text":"<p>This method sets the RF read and write protection for the specified memory area 1-4.</p> <p>The default protection for all memory areas is <code>RF_RW_READ_ALWAYS_WRITE_ALWAYS</code>.</p> <p>Note</p> <p>Area 1 is always readable via RF. Calling <code>setAreaRfRwProtection(1, RF_RW_READ_SECURITY_WRITE_SECURITY)</code> or <code>setAreaRfRwProtection(1, RF_RW_READ_SECURITY_WRITE_NEVER)</code> has no effect.</p> <pre><code>bool setAreaRfRwProtection(uint8_t memoryArea, SF_ST25DV_RF_RW_PROTECTION rw)\n</code></pre> <p>The permissible values for <code>rw</code> are:</p> <pre><code>RF_RW_READ_ALWAYS_WRITE_ALWAYS,\nRF_RW_READ_ALWAYS_WRITE_SECURITY,\nRF_RW_READ_SECURITY_WRITE_SECURITY, // For Area 1: Read is always allowed\nRF_RW_READ_SECURITY_WRITE_NEVER     // For Area 1: Read is always allowed\n</code></pre> Parameter Type Description <code>memoryArea</code> <code>uint8_t</code> The memory area 1-4 <code>rw</code> <code>enum class SF_ST25DV_RF_RW_PROTECTION</code> The level of read/write protection return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#getarearfrwprotection","title":"getAreaRfRwProtection()","text":"<p>This method returns the level of RF read and write protection for the specified memory area 1-4.</p> <p>If a read error occurs, an error callback is triggered.</p> <pre><code>SF_ST25DV_RF_RW_PROTECTION getAreaRfRwProtection(uint8_t memoryArea)\n</code></pre> Parameter Type Description <code>memoryArea</code> <code>uint8_t</code> The memory area 1-4 return value <code>enum class SF_ST25DV_RF_RW_PROTECTION</code> The level of read/write protection"},{"location":"api_SFE_ST25DV64KC/#setarearfpwdctrl","title":"setAreaRfPwdCtrl()","text":"<p>This method defines which password is required to open a security session for the specified memory area 1-4.</p> <p>An \"RF Configuration\" security session can be opened by entering RF Password 0. This session allows the tag's configuration static registers and RF Password 0 to be modified via RF. The default RF Password 0 is ( 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ).</p> <p>An \"RF User\" security session can be opened by entering RF Password 1-3. This session allows the user access to protected user memory as defined by <code>setAreaRfRwProtection</code>. The matching RF Password (1-3) can also be changed while the session is open.</p> <p>By default, the <code>pwdCtrl</code> setting for each memory area is <code>RF_PWD_NEVER</code>, meaning that a RF User security session can not be opened by password.</p> <p>Attention</p> <p>To protect a tag against unwanted changes via an RF Configuration Session, RF Password 0 should be changed using an App like ST's \"NFC Tap\". It is not possible to do this via I<sup>2</sup>C. The I<sup>2</sup>C interface has no access to the four RF passwords.</p> <pre><code>bool setAreaRfPwdCtrl(uint8_t memoryArea, SF_ST25DV_RF_PWD_CTRL pwdCtrl)\n</code></pre> <p>The permissible values for <code>pwdCtrl</code> are:</p> <pre><code>RF_PWD_NEVER,\nRF_PWD_PWD1,\nRF_PWD_PWD2,\nRF_PWD_PWD3\n</code></pre> Parameter Type Description <code>memoryArea</code> <code>uint8_t</code> The memory area 1-4 <code>pwdCtrl</code> <code>enum class SF_ST25DV_RF_PWD_CTRL</code> The selected password option return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#getarearfpwdctrl","title":"getAreaRfPwdCtrl()","text":"<p>This method returns the selected password option for the specified memory area 1-4.</p> <p>If a read error occurs, an error callback is triggered.</p> <pre><code>SF_ST25DV_RF_PWD_CTRL getAreaRfPwdCtrl(uint8_t memoryArea)\n</code></pre> Parameter Type Description <code>memoryArea</code> <code>uint8_t</code> The memory area 1-4 return value <code>enum class SF_ST25DV_RF_PWD_CTRL</code> The selected password option"},{"location":"api_SFE_ST25DV64KC/#eeprom-read-and-write","title":"EEPROM Read and Write","text":""},{"location":"api_SFE_ST25DV64KC/#readeeprom","title":"readEEPROM()","text":"<p>This method reads <code>dataLength</code> bytes from EEPROM memory, starting at <code>baseAddress</code>. The bytes are returned in <code>data</code>.</p> <p>Note</p> <p><code>data</code> must be sufficiently large to hold all <code>dataLength</code> bytes.</p> <pre><code>bool readEEPROM(uint16_t baseAddress, uint8_t *data, uint16_t dataLength)\n</code></pre> Parameter Type Description <code>baseAddress</code> <code>uint16_t</code> The base (start) EEPROM address for the read <code>data</code> <code>uint8_t *</code> A pointer to an array of uint8_t to hold the read data <code>dataLength</code> <code>uint16_t</code> The number of bytes to be read return value <code>bool</code> <code>true</code> if the read is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#writeeeprom","title":"writeEEPROM()","text":"<p>This method writes <code>dataLength</code> bytes to EEPROM memory, starting at <code>baseAddress</code>. The bytes to be written are held in <code>data</code>.</p> <pre><code>bool writeEEPROM(uint16_t baseAddress, uint8_t *data, uint16_t dataLength)\n</code></pre> Parameter Type Description <code>baseAddress</code> <code>uint16_t</code> The base (start) EEPROM address for the write <code>data</code> <code>uint8_t *</code> A pointer to an array of uint8_t which holds the data to be written <code>dataLength</code> <code>uint16_t</code> The number of bytes to be written return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#rf-detection","title":"RF Detection","text":""},{"location":"api_SFE_ST25DV64KC/#rffielddetected","title":"RFFieldDetected()","text":"<p>This method detects if an RF field is present.</p> <pre><code>bool RFFieldDetected()\n</code></pre> Parameter Type Description return value <code>bool</code> <code>true</code> if an RF field is detected, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#gpo-control","title":"GPO Control","text":""},{"location":"api_SFE_ST25DV64KC/#setgpo1bit","title":"setGPO1Bit","text":"<p>This method sets or clears the selected bit(s) in the GPO1 register.</p> <p>Multiple bits can be set or cleared with a single call.</p> <pre><code>bool setGPO1Bit(uint8_t bitMask, bool enabled)\n</code></pre> <p>The GPO1 bit definitions are:</p> <pre><code>#define BIT_GPO1_GPO_EN (1 &lt;&lt; 0)\n#define BIT_GPO1_RF_USER_EN (1 &lt;&lt; 1)\n#define BIT_GPO1_RF_ACTIVITY_EN (1 &lt;&lt; 2)\n#define BIT_GPO1_RF_INTERRUPT_EN (1 &lt;&lt; 3)\n#define BIT_GPO1_FIELD_CHANGE_EN (1 &lt;&lt; 4)\n#define BIT_GPO1_RF_PUT_MSG_EN (1 &lt;&lt; 5)\n#define BIT_GPO1_RF_GET_MSG_EN (1 &lt;&lt; 6)\n#define BIT_GPO1_RF_WRITE_EN (1 &lt;&lt; 7)\n</code></pre> Parameter Type Description <code>bitMask</code> <code>uint8_t</code> The bit(s) to be set or cleared <code>enabled</code> <code>bool</code> If <code>true</code>, the bit(s) set in <code>bitMask</code> are set. If <code>false</code>, the bit(s) set in <code>bitMask</code> are cleared. return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#getgpo1bit","title":"getGPO1Bit()","text":"<p>This method returns the state of the selected bit in the GPO1 register.</p> <pre><code>bool getGPO1Bit(uint8_t bitMask)\n</code></pre> Parameter Type Description <code>bitMask</code> <code>uint8_t</code> The bit to be read return value <code>bool</code> <code>true</code> if the bit is set, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#setgpo2bit","title":"setGPO2Bit","text":"<p>This method sets or clears the selected bit(s) in the GPO2 register.</p> <p>Multiple bits can be set or cleared with a single call.</p> <pre><code>bool setGPO2Bit(uint8_t bitMask, bool enabled)\n</code></pre> <p>The GPO2 bit defintions are:</p> <pre><code>#define BIT_GPO2_I2C_WRITE_EN (1 &lt;&lt; 0)\n#define BIT_GPO2_I2C_RF_OFF_EN (1 &lt;&lt; 1)\n</code></pre> Parameter Type Description <code>bitMask</code> <code>uint8_t</code> The bit(s) to be set or cleared <code>enabled</code> <code>bool</code> If <code>true</code>, the bit(s) set in <code>bitMask</code> are set. If <code>false</code>, the bit(s) set in <code>bitMask</code> are cleared. return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#getgpo2bit","title":"getGPO2Bit()","text":"<p>This method returns the state of the selected bit in the GPO2 register.</p> <pre><code>bool getGPO2Bit(uint8_t bitMask)\n</code></pre> Parameter Type Description <code>bitMask</code> <code>uint8_t</code> The bit to be read return value <code>bool</code> <code>true</code> if the bit is set, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#setgpo_ctrl_dynbit","title":"setGPO_CTRL_DynBit()","text":"<p>This method sets or clears the GPO_EN bit in the GPO_CTRL_Dyn (Dynamic) register. This allows the GPO pin to be enabled or disabled without making non-volatile changes to the GPO1 register GPO_EN bit.</p> <pre><code>bool setGPO_CTRL_DynBit(bool enabled)\n</code></pre> Parameter Type Description <code>enabled</code> <code>bool</code> If <code>true</code>, the GPO_EN bit is set, otherwise it is cleared return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#getgpo_ctrl_dynbit","title":"getGPO_CTRL_DynBit()","text":"<p>This method retruns the state of the GPO_EN bit in the GPO_CTRL_Dyn (Dynamic) register.</p> <pre><code>bool getGPO_CTRL_DynBit()\n</code></pre> Parameter Type Description return value <code>bool</code> <code>true</code> if the GPO_EN bit is set, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#interrupt-status","title":"Interrupt Status","text":""},{"location":"api_SFE_ST25DV64KC/#getit_sts_dyn","title":"getIT_STS_Dyn()","text":"<p>This method returns the content of the dynamic Interrupt Status register IT_SYS_Dyn, indicating the cause of an interrupt.</p> <p>If a read error occurs, an error callback is triggered.</p> <p>Note</p> <p>Once read, the ITSTS_Dyn register is cleared (set to 00h).</p> <pre><code>uint8_t getIT_STS_Dyn();\n</code></pre> <p>The bit definitions of the IT_SYS_Dyn register are:</p> <pre><code>#define BIT_IT_STS_DYN_RF_USER (1 &lt;&lt; 0)\n#define BIT_IT_STS_DYN_RF_ACTIVITY (1 &lt;&lt; 1)\n#define BIT_IT_STS_DYN_RF_INTERRUPT (1 &lt;&lt; 2)\n#define BIT_IT_STS_DYN_FIELD_FALLING (1 &lt;&lt; 3)\n#define BIT_IT_STS_DYN_FIELD_RISING (1 &lt;&lt; 4)\n#define BIT_IT_STS_DYN_RF_PUT_MSG (1 &lt;&lt; 5)\n#define BIT_IT_STS_DYN_RF_GET_MSG (1 &lt;&lt; 6)\n#define BIT_IT_STS_DYN_RF_WRITE (1 &lt;&lt; 7)\n</code></pre> Parameter Type Description return value <code>uint8_t</code> The register value"},{"location":"api_SFE_ST25DV64KC/#energy-harvesting","title":"Energy Harvesting","text":""},{"location":"api_SFE_ST25DV64KC/#seteh_modebit","title":"setEH_MODEBit()","text":"<p>This method sets or clears the Energy Harvesting EH_MODE bit in the EH_MODE register.</p> <pre><code>bool setEH_MODEBit(bool value)\n</code></pre> Parameter Type Description <code>value</code> <code>bool</code> If <code>true</code>, Energy Harvesting is on demand only (default). If <code>false</code>, EH  is forced after boot return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#geteh_modebit","title":"getEH_MODEBit()","text":"<p>This method returns the state of the Energy Harvesting EH_MODE bit in the EH_MODE register.</p> <pre><code>bool getEH_MODEBit()\n</code></pre> Parameter Type Description return value <code>bool</code> <code>true</code> if the EH_MODE bit is set, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#seteh_ctrl_dynbit","title":"setEH_CTRL_DYNBit()","text":"<p>This method will set or clear bit(s) in the dynamic EH_CTRL_Dyn register. This allows energy harvesting to be enabled or disabled without making non-volatile changes to the EH_MODE register.</p> <pre><code>bool setEH_CTRL_DYNBit(uint8_t bitMask, bool value)\n</code></pre> Parameter Type Description <code>bitMask</code> <code>uint8_t</code> The bit(s) to be set or cleared <code>value</code> <code>bool</code> If <code>true</code>, the bit(s) set in <code>bitMask</code> are set. If <code>false</code>, the bit(s) set in <code>bitMask</code> are cleared return value <code>bool</code> <code>true</code> if the write is successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#geteh_ctrl_dynbit","title":"getEH_CTRL_DYNBit()","text":"<p>This method returns the state of the select bit in the dynamic EH_CTRL_Dyn register.</p> <p>Note</p> <p>If multiple bits are set in <code>bitMask</code>, the method will return <code>true</code> if any one of those bits is set.</p> <pre><code>bool getEH_CTRL_DYNBit(uint8_t bitMask)\n</code></pre> Parameter Type Description <code>bitMask</code> <code>uint8_t</code> The bit to be read return value <code>bool</code> <code>true</code> if the bit is set, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#helper-methods","title":"Helper Methods","text":""},{"location":"api_SFE_ST25DV64KC/#errorcodestring","title":"errorCodeString()","text":"<p>This method converts an <code>SF_ST25DV64KC_ERROR</code> error code into readable text.</p> <pre><code>const char *errorCodeString(SF_ST25DV64KC_ERROR errorCode)\n</code></pre> Parameter Description <code>errorCode</code> The <code>enum class SF_ST25DV64KC_ERROR</code> error code return value <code>const char *</code>"},{"location":"api_SFE_ST25DV64KC/#readregistervalue","title":"readRegisterValue()","text":"<p>This method reads a single register value.</p> <pre><code>bool readRegisterValue(const SF_ST25DV64KC_ADDRESS addressType, const uint16_t registerAddress, uint8_t *value)\n</code></pre> <p>This is the equivalent of calling:</p> <pre><code>tag-&gt;st25_io.readSingleByte(addressType, registerAddress, value)\n</code></pre> <p>Possible values for <code>addressType</code> are:</p> <pre><code>DATA,          // E2 = 0, E1 = 1\nSYSTEM,        // E2 = 1, E1 = 1\nRF_SWITCH_OFF, // E2 = 0, E1 = 0\nRF_SWITCH_ON,  // E2 = 1, E1 = 0\n</code></pre> Parameter Type Description <code>addressType</code> <code>enum class SF_ST25DV64KC_ADDRESS</code> The register type, equivalent to the I<sup>2</sup>C address <code>registerAddress</code> <code>const uint16_t</code> The register address <code>value</code> <code>uint8_t *</code> <code>value</code> will hold the register value on return return value <code>bool</code> <code>true</code> if the read was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#readregistervalues","title":"readRegisterValues()","text":"<p>This method reads multiple register values.</p> <p>Note</p> <p><code>data</code> must be sufficiently large to hold all <code>dataLength</code> bytes.</p> <pre><code>bool readRegisterValues(const SF_ST25DV64KC_ADDRESS addressType, const uint16_t registerAddress, uint8_t *data, const uint16_t dataLength)\n</code></pre> <p>This is the equivalent of calling:</p> <pre><code>tag-&gt;st25_io.readMultipleBytes(addressType, registerAddress, data, dataLength)\n</code></pre> <p>Possible values for <code>addressType</code> are:</p> <pre><code>DATA,          // E2 = 0, E1 = 1\nSYSTEM,        // E2 = 1, E1 = 1\nRF_SWITCH_OFF, // E2 = 0, E1 = 0\nRF_SWITCH_ON,  // E2 = 1, E1 = 0\n</code></pre> Parameter Type Description <code>addressType</code> <code>enum class SF_ST25DV64KC_ADDRESS</code> The register type, equivalent to the I<sup>2</sup>C address <code>registerAddress</code> <code>const uint16_t</code> The start register address <code>data</code> <code>uint8_t *</code> <code>data</code> will hold the register values on return <code>dataLength</code> <code>const uint16_t</code> The number of registers to be read return value <code>bool</code> <code>true</code> if the read was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC/#member-variables","title":"Member Variables","text":"Parameter Type Description <code>st25_io</code> <code>class SFE_ST2525DV64KC_IO</code> An instance of the <code>SFE_ST2525DV64KC_IO</code> class, providing I<sup>2</sup>C communication methods and storage for <code>wirePort</code>"},{"location":"api_SFE_ST25DV64KC_IO/","title":"API Reference for the SFE_ST25DV64KC_IO class","text":""},{"location":"api_SFE_ST25DV64KC_IO/#brief-overview","title":"Brief Overview","text":"<p>The <code>SFE_ST25DV64KC_IO</code> class provides the interface to the ST25DV hardware via I<sup>2</sup>C. It provides methods to: read and write single and multiple register values, set or clear individual register bits, and confirm if a register bit is set.</p>"},{"location":"api_SFE_ST25DV64KC_IO/#initialization","title":"Initialization","text":""},{"location":"api_SFE_ST25DV64KC_IO/#begin","title":"begin()","text":"<p>This method records the specified TwoWire port and uses that for all future I<sup>2</sup>C communication.</p> <p>It also calls <code>isConnected()</code> and returns the result, confirming whether the ST25DV has been detected successfully.</p> <pre><code>bool begin(TwoWire &amp;wirePort)\n</code></pre> Parameter Type Description <code>wirePort</code> <code>TwoWire &amp;</code> The I<sup>2</sup>C port to be used to communicate with the ST25DV return value <code>bool</code> <code>true</code> if the ST25DV is detected, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_IO/#isconnected","title":"isConnected()","text":"<p>This method confirms if the ST25DV is connected by polling one of its I<sup>2</sup>C addresses.</p> <pre><code>bool isConnected()\n</code></pre> Parameter Type Description return value <code>bool</code> <code>true</code> if the ST25DV is detected, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_IO/#register-read-write","title":"Register Read / Write","text":""},{"location":"api_SFE_ST25DV64KC_IO/#readsinglebyte","title":"readSingleByte()","text":"<p>This method reads a single register and returns the contents.</p> <pre><code>bool readSingleByte(const SF_ST25DV64KC_ADDRESS address, const uint16_t registerAddress, uint8_t *value)\n</code></pre> <p>Possible values for <code>address</code> are:</p> <pre><code>DATA,          // E2 = 0, E1 = 1\nSYSTEM,        // E2 = 1, E1 = 1\nRF_SWITCH_OFF, // E2 = 0, E1 = 0\nRF_SWITCH_ON,  // E2 = 1, E1 = 0\n</code></pre> Parameter Type Description <code>address</code> <code>enum class SF_ST25DV64KC_ADDRESS</code> The register type, equivalent to the I<sup>2</sup>C address <code>registerAddress</code> <code>const uint16_t</code> The register address <code>value</code> <code>uint8_t *</code> <code>value</code> will hold the register value on return return value <code>bool</code> <code>true</code> if the read was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_IO/#writesinglebyte","title":"writeSingleByte()","text":"<p>This method writes a value to the specified register.</p> <pre><code>bool writeSingleByte(const SF_ST25DV64KC_ADDRESS address, const uint16_t registerAddress, const uint8_t value)\n</code></pre> <p>Possible values for <code>address</code> are:</p> <pre><code>DATA,          // E2 = 0, E1 = 1\nSYSTEM,        // E2 = 1, E1 = 1\nRF_SWITCH_OFF, // E2 = 0, E1 = 0\nRF_SWITCH_ON,  // E2 = 1, E1 = 0\n</code></pre> Parameter Type Description <code>address</code> <code>enum class SF_ST25DV64KC_ADDRESS</code> The register type, equivalent to the I<sup>2</sup>C address <code>registerAddress</code> <code>const uint16_t</code> The register address <code>value</code> <code>const uint8_t</code> The value to be written return value <code>bool</code> <code>true</code> if the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_IO/#readmultiplebytes","title":"readMultipleBytes()","text":"<p>This method reads and returns multiple register values, starting at <code>registerAddress</code>.</p> <p>Note</p> <p><code>buffer</code> must be sufficiently large to hold all <code>packetLength</code> bytes.</p> <pre><code>bool readMultipleBytes(const SF_ST25DV64KC_ADDRESS address, const uint16_t registerAddress, uint8_t *const buffer, const uint16_t packetLength)\n</code></pre> <p>Possible values for <code>address</code> are:</p> <pre><code>DATA,          // E2 = 0, E1 = 1\nSYSTEM,        // E2 = 1, E1 = 1\nRF_SWITCH_OFF, // E2 = 0, E1 = 0\nRF_SWITCH_ON,  // E2 = 1, E1 = 0\n</code></pre> Parameter Type Description <code>address</code> <code>enum class SF_ST25DV64KC_ADDRESS</code> The register type, equivalent to the I<sup>2</sup>C address <code>registerAddress</code> <code>const uint16_t</code> The start register address <code>buffer</code> <code>uint8_t *const</code> A pointer to the array of uint8_t which will hold the read values <code>packetLength</code> <code>const uint16_t</code> The number of registers to be read return value <code>bool</code> <code>true</code> if the read was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_IO/#writemultiplebytes","title":"writeMultipleBytes()","text":"<p>This method writes values to multiple registers, starting at <code>registerAddress</code>.</p> <pre><code>bool writeMultipleBytes(const SF_ST25DV64KC_ADDRESS address, const uint16_t registerAddress, uint8_t *const buffer, const uint16_t packetLength)\n</code></pre> <p>Possible values for <code>address</code> are:</p> <pre><code>DATA,          // E2 = 0, E1 = 1\nSYSTEM,        // E2 = 1, E1 = 1\nRF_SWITCH_OFF, // E2 = 0, E1 = 0\nRF_SWITCH_ON,  // E2 = 1, E1 = 0\n</code></pre> Parameter Type Description <code>address</code> <code>enum class SF_ST25DV64KC_ADDRESS</code> The register type, equivalent to the I<sup>2</sup>C address <code>registerAddress</code> <code>const uint16_t</code> The start register address <code>buffer</code> <code>uint8_t *const</code> A pointer to the array of uint8_t which holds the values to be written <code>packetLength</code> <code>const uint16_t</code> The number of values to be written return value <code>bool</code> <code>true</code> if the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_IO/#register-bit-manipulation","title":"Register Bit Manipulation","text":""},{"location":"api_SFE_ST25DV64KC_IO/#setregisterbit","title":"setRegisterBit()","text":"<p>This method will set the bit(s) defined by <code>bitMask</code> in the selected register.</p> <p>This method uses a read-modify-write to set the bit(s).</p> <pre><code>bool setRegisterBit(const SF_ST25DV64KC_ADDRESS address, const uint16_t registerAddress, const uint8_t bitMask)\n</code></pre> Parameter Type Description <code>address</code> <code>enum class SF_ST25DV64KC_ADDRESS</code> The register type, equivalent to the I<sup>2</sup>C address <code>registerAddress</code> <code>const uint16_t</code> The register address <code>bitMask</code> <code>const uint8_t</code> Defines which bits will be set. Each bit set in <code>bitMask</code> will cause the corresponding bit in <code>registerAddress</code> to be set return value <code>bool</code> <code>true</code> if the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_IO/#clearregisterbit","title":"clearRegisterBit()","text":"<p>This method will clear the bit(s) defined by <code>bitMask</code> in the selected register.</p> <p>This method uses a read-modify-write to clear the bit(s).</p> <pre><code>bool clearRegisterBit(const SF_ST25DV64KC_ADDRESS address, const uint16_t registerAddress, const uint8_t bitMask)\n</code></pre> Parameter Type Description <code>address</code> <code>enum class SF_ST25DV64KC_ADDRESS</code> The register type, equivalent to the I<sup>2</sup>C address <code>registerAddress</code> <code>const uint16_t</code> The register address <code>bitMask</code> <code>const uint8_t</code> Defines which bits will be cleared. Each bit set in <code>bitMask</code> will cause the corresponding bit in <code>registerAddress</code> to be cleared return value <code>bool</code> <code>true</code> if the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_IO/#isbitset","title":"isBitSet()","text":"<p>This method returns <code>true</code> if the bit selected in <code>bitMask</code> is set.</p> <p>Note</p> <p>If multiple bits are set in <code>bitMask</code>, the method will return <code>true</code> if any one of those bits is set.</p> <pre><code>bool isBitSet(const SF_ST25DV64KC_ADDRESS address, const uint16_t registerAddress, const uint8_t bitMask)\n</code></pre> Parameter Type Description <code>address</code> <code>enum class SF_ST25DV64KC_ADDRESS</code> The register type, equivalent to the I<sup>2</sup>C address <code>registerAddress</code> <code>const uint16_t</code> The register address <code>bitMask</code> <code>const uint8_t</code> Defines which bits will be tested return value <code>bool</code> <code>true</code> if the bit defined by <code>bitMask</code> is set, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_IO/#member-variables","title":"Member Variables","text":"<p>Note</p> <p>When the ST25DV is busy writing to its internal <code>DATA</code> memory, it will NACK any further attempted I<sup>2</sup>C transmissions until the write is complete. The write duration is variable and depends on whether the write crosses block boundaries. Therefore, the library implements a retry strategy. Each read or write will be attempted up to <code>maxRetries</code> times, with a delay of <code>retryDelay</code> in between, before an error is triggered.</p> Parameter Type Description <code>readWriteChunkSize</code> <code>uint8_t</code> The number of bytes that will be read or written in a single I<sup>2</sup>C transmission. Default is 32 <code>maxRetries</code> <code>const uint8_t</code> The maximum number of times a register read or write wil be attempted before triggering an error. Set to 6 <code>retryDelay</code> <code>const uint8_t</code> The number of milliseconds delay between read or write attempts. Set to 5"},{"location":"api_SFE_ST25DV64KC_NDEF/","title":"API Reference for the SFE_ST25DV64KC_NDEF class","text":""},{"location":"api_SFE_ST25DV64KC_NDEF/#brief-overview","title":"Brief Overview","text":"<p>The <code>SFE_ST25DV64KC_NDEF</code> class provides additional methods to read and write NDEF (NFC Forum Data Exchange Format) records from EEPROM memory. The <code>SFE_ST25DV64KC_NDEF</code> class inherits all of the methods of the <code>SFE_ST25DV64KC</code> class.</p>"},{"location":"api_SFE_ST25DV64KC_NDEF/#capability-container-methods","title":"Capability Container Methods","text":""},{"location":"api_SFE_ST25DV64KC_NDEF/#writeccfile4byte","title":"writeCCFile4Byte()","text":"<p>This method will write a 4-byte Capability Container file to the first 4 bytes of EEPROM memory.</p> <p>Note</p> <p>This method is only useful for small tags like the ST25DV04KC. The ST25DV64KC requires an 8-byte CC file.</p> <pre><code>bool writeCCFile4Byte(uint32_t val)\n</code></pre> Parameter Type Description <code>val</code> <code>uint32_t</code> The 32-bit (4-byte) capability container. Default is 0xE1403F00 return value <code>bool</code> <code>true</code> is the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_NDEF/#writeccfile8byte","title":"writeCCFile8Byte()","text":"<p>This method will write a 8-byte Capability Container file to the first 8 bytes of EEPROM memory.</p> <pre><code>bool writeCCFile8Byte(uint32_t val1, uint32_t val2)\n</code></pre> Parameter Type Description <code>val1</code> <code>uint32_t</code> The first 32-bits (4-bytes) of the capability container. Default is 0xE2400001 <code>val2</code> <code>uint32_t</code> The second 32-bits (4-bytes) of the capability container. Default is 0x000003FF return value <code>bool</code> <code>true</code> is the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_NDEF/#setccfilelen","title":"setCCFileLen()","text":"<p>This method allows the <code>_ccFileLen</code> member variable to be manually updated if required.</p> <p><code>_ccFileLen</code> has a default value of 8 (for the ST25DV64KC).</p> <p><code>_ccFileLen</code> is automatically set to 4 when <code>writeCCFile4Byte</code> is called. <code>_ccFileLen</code> is automatically set to 8 when <code>writeCCFile8Byte</code> is called.</p> <pre><code>void setCCFileLen(uint16_t newLen)\n</code></pre> Parameter Type Description <code>newLen</code> <code>uint16_t</code> The new value for <code>_ccFileLen</code>"},{"location":"api_SFE_ST25DV64KC_NDEF/#getccfilelen","title":"getCCFileLen()","text":"<p>This method returns the current value of <code>_ccFileLen</code>. It returns the correct start address to be passed to the <code>writeNDEF</code> functions.</p> <pre><code>uint16_t getCCFileLen()\n</code></pre> Parameter Type Description return value <code>uint16_t</code> The current value of <code>_ccFileLen</code>"},{"location":"api_SFE_ST25DV64KC_NDEF/#ndef-methods","title":"NDEF Methods","text":""},{"location":"api_SFE_ST25DV64KC_NDEF/#writendefempty","title":"writeNDEFEmpty()","text":"<p>This method writes an empty (zero-length) NDEF record to EEPROM. It can be useful to call this after clearing the EEPROM memory and writing the CC File. This allows the smart phone App to read the NDEF file - even though it is empty.</p> <pre><code>bool SFE_ST25DV64KC_NDEF::writeNDEFEmpty(uint16_t *address)\n</code></pre> Parameter Type Description <code>address</code> <code>uint16_t *</code> A pointer to a <code>uint16_t</code> containing the start address for this record. Default is <code>NULL</code>. If not provided, the record is written to <code>_ccFileLen</code> return value <code>bool</code> <code>true</code> if the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_NDEF/#writendefuri","title":"writeNDEFURI()","text":"<p>This method writes an NDEF URI record to EEPROM.</p> <p>The URI is passed in <code>uri</code>.</p> <p>Setting <code>idCode</code> to the appropriate ID Code will save memory. The URI prefix (e.g. <code>https://www.</code> ) is then stored as a single byte.</p> <p>Multiple records can be written by: providing an <code>address</code> plus Message Begin (<code>MB</code>) and Message End (<code>ME</code>) flags.</p> <p>If <code>address</code> is provided, it is updated with the memory location after the final one written as part of this record. This allows it to be used as the start address for the next record.</p> <p>A single record has both <code>MB</code> and <code>ME</code> flags set <code>true</code>.</p> <p>The TLV T and L fields are set automatically. The L field is updated from 1-byte to 3-byte automatically if the new record takes the total length beyond 254 bytes.</p> <pre><code>bool writeNDEFURI(const char *uri, uint8_t idCode, uint16_t *address, bool MB, bool ME)\n</code></pre> <p>Possible values for <code>idCode</code> are:</p> <pre><code>#define SFE_ST25DV_NDEF_URI_ID_CODE_NONE 0x00\n#define SFE_ST25DV_NDEF_URI_ID_CODE_HTTP_WWW 0x01\n#define SFE_ST25DV_NDEF_URI_ID_CODE_HTTPS_WWW 0x02\n#define SFE_ST25DV_NDEF_URI_ID_CODE_HTTP 0x03\n#define SFE_ST25DV_NDEF_URI_ID_CODE_HTTPS 0x04\n#define SFE_ST25DV_NDEF_URI_ID_CODE_TEL 0x05\n#define SFE_ST25DV_NDEF_URI_ID_CODE_MAILTO 0x06\n#define SFE_ST25DV_NDEF_URI_ID_CODE_FTP_ANON_ANON 0x07\n#define SFE_ST25DV_NDEF_URI_ID_CODE_FTP_FTP 0x08\n#define SFE_ST25DV_NDEF_URI_ID_CODE_FTPS 0x09\n#define SFE_ST25DV_NDEF_URI_ID_CODE_SFTP 0x0A\n#define SFE_ST25DV_NDEF_URI_ID_CODE_SMB 0x0B\n#define SFE_ST25DV_NDEF_URI_ID_CODE_NFS 0x0C\n#define SFE_ST25DV_NDEF_URI_ID_CODE_FTP 0x0D\n#define SFE_ST25DV_NDEF_URI_ID_CODE_DAV 0x0E\n#define SFE_ST25DV_NDEF_URI_ID_CODE_NEWS 0x0F\n#define SFE_ST25DV_NDEF_URI_ID_CODE_TELNET 0x10\n#define SFE_ST25DV_NDEF_URI_ID_CODE_IMAP 0x11\n#define SFE_ST25DV_NDEF_URI_ID_CODE_RTSP 0x12\n#define SFE_ST25DV_NDEF_URI_ID_CODE_URN 0x13\n#define SFE_ST25DV_NDEF_URI_ID_CODE_POP 0x14\n#define SFE_ST25DV_NDEF_URI_ID_CODE_SIP 0x15\n#define SFE_ST25DV_NDEF_URI_ID_CODE_SIPS 0x16\n#define SFE_ST25DV_NDEF_URI_ID_CODE_TFTP 0x17\n#define SFE_ST25DV_NDEF_URI_ID_CODE_BTSPP 0x18\n#define SFE_ST25DV_NDEF_URI_ID_CODE_BTL2CAP 0x19\n#define SFE_ST25DV_NDEF_URI_ID_CODE_BTGOEP 0x1A\n#define SFE_ST25DV_NDEF_URI_ID_CODE_TCPOBEX 0x1B\n#define SFE_ST25DV_NDEF_URI_ID_CODE_IRDAOBEX 0x1C\n#define SFE_ST25DV_NDEF_URI_ID_CODE_FILE 0x1D\n#define SFE_ST25DV_NDEF_URI_ID_CODE_URN_EPC_ID 0x1E\n#define SFE_ST25DV_NDEF_URI_ID_CODE_URN_EPC_TAG 0x1F\n#define SFE_ST25DV_NDEF_URI_ID_CODE_URN_EPC_PAT 0x20\n#define SFE_ST25DV_NDEF_URI_ID_CODE_URN_EPC_RAW 0x21\n#define SFE_ST25DV_NDEF_URI_ID_CODE_URN_EPC 0x22\n#define SFE_ST25DV_NDEF_URI_ID_CODE_URN_NFC 0x23\n</code></pre> Parameter Type Description <code>uri</code> <code>const char *</code> A pointer to the URI <code>idCode</code> <code>uint8_t</code> The URI prefix. <code>SFE_ST25DV_NDEF_URI_ID_CODE_HTTPS_WWW</code> = <code>https://www.</code> etc.. Default is <code>SFE_ST25DV_NDEF_URI_ID_CODE_NONE</code> <code>address</code> <code>uint16_t *</code> A pointer to a <code>uint16_t</code> containing the start address for this record. Default is <code>NULL</code>. If not provided, the record is written to <code>_ccFileLen</code> <code>MB</code> <code>bool</code> Message Begin flag. Default is <code>true</code> <code>ME</code> <code>bool</code> Message End flag. Default is <code>true</code> return value <code>bool</code> <code>true</code> if the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_NDEF/#readndefuri","title":"readNDEFURI()","text":"<p>This method reads and returns a single NDEF URI from EEPROM.</p> <p>By default, the first record is returned. The second and subsequent records can be read by setting <code>recordNo</code> to the desired value.</p> <p>If the chosen <code>recordNo</code> is not present, the method returns <code>false</code>. This provides an easy way to count the number of URIs in memory.</p> <pre><code>bool readNDEFURI(char *theURI, uint16_t maxURILen, uint8_t recordNo)\n</code></pre> Parameter Type Description <code>theURI</code> <code>char *</code> A pointer to the char array which will hold the URI <code>maxURILen</code> <code>uint16_t</code> The maximum number of bytes which <code>theURI</code> can hold. I.e. the <code>sizeof</code> of <code>theURI</code> <code>recordNo</code> <code>uint8_t</code> The URI record to be read. Default is 1 return value <code>bool</code> <code>true</code> if the read is successful (i.e. <code>recordNo</code> exists), <code>false</code> otherwise"},{"location":"api_SFE_ST25DV64KC_NDEF/#writendefwifi","title":"writeNDEFWiFi()","text":"<p>This method writes an NDEF WiFi record to EEPROM.</p> <p>The WiFi SSID and Password are passed in <code>ssid</code> and <code>passwd</code>.</p> <p>Multiple records can be written by: providing an <code>address</code> plus Message Begin (<code>MB</code>) and Message End (<code>ME</code>) flags.</p> <p>If <code>address</code> is provided, it is updated with the memory location after the final one written as part of this record. This allows it to be used as the start address for the next record.</p> <p>A single record has both <code>MB</code> and <code>ME</code> flags set <code>true</code>.</p> <p>The TLV T and L fields are set automatically. The L field is updated from 1-byte to 3-byte automatically if the new record takes the total length beyond 254 bytes.</p> <p><code>auth</code> (the WiFi authentication) defaults to <code>SFE_ST25DV_WIFI_AUTH_WPA2_PERSONAL</code>, as specified by the Wi-Fi Simple Configuration Technical Specification.</p> <p><code>encrypt</code> (the WiFi encryption) defaults to <code>SFE_ST25DV_WIFI_ENCRYPT_AES</code>, as specified by the Wi-Fi Simple Configuration Technical Specification.</p> <pre><code>bool writeNDEFWiFi(const char *ssid, const char *passwd, uint16_t *address, bool MB, bool ME, const uint8_t auth[2], const uint8_t encrypt[2])\n</code></pre> <p>Possible values for <code>auth</code> and <code>encrypt</code> are:</p> <pre><code>static const uint8_t SFE_ST25DV_WIFI_AUTH_OPEN[2] = {0x00, 0x01};\nstatic const uint8_t SFE_ST25DV_WIFI_AUTH_WPA_PERSONAL[2] = {0x00, 0x02};\nstatic const uint8_t SFE_ST25DV_WIFI_AUTH_SHARED[2] = {0x00, 0x04};\nstatic const uint8_t SFE_ST25DV_WIFI_AUTH_WPA_ENTERPRISE[2] = {0x00, 0x08};\nstatic const uint8_t SFE_ST25DV_WIFI_AUTH_WPA2_ENTERPRISE[2] = {0x00, 0x10};\nstatic const uint8_t SFE_ST25DV_WIFI_AUTH_WPA2_PERSONAL[2] = {0x00, 0x20};\nstatic const uint8_t SFE_ST25DV_WIFI_AUTH_WPA_WPA2_PERSONAL[2] = {0x00, 0x22};\n\nstatic const uint8_t SFE_ST25DV_WIFI_ENCRYPT_NONE[2] = {0x00, 0x01};\nstatic const uint8_t SFE_ST25DV_WIFI_ENCRYPT_WEP[2] = {0x00, 0x02};\nstatic const uint8_t SFE_ST25DV_WIFI_ENCRYPT_TKIP[2] = {0x00, 0x04};\nstatic const uint8_t SFE_ST25DV_WIFI_ENCRYPT_AES[2] = {0x00, 0x08};\nstatic const uint8_t SFE_ST25DV_WIFI_ENCRYPT_AES_TKIP[2] = {0x00, 0x0C};\n</code></pre> Parameter Type Description <code>ssid</code> <code>const char *</code> A pointer to the SSID (Network Name) <code>passwd</code> <code>const char *</code> A pointer to the password (Network Key) <code>address</code> <code>uint16_t *</code> A pointer to a <code>uint16_t</code> containing the start address for this record. Default is <code>NULL</code>. If not provided, the record is written to <code>_ccFileLen</code> <code>MB</code> <code>bool</code> Message Begin flag. Default is <code>true</code> <code>ME</code> <code>bool</code> Message End flag. Default is <code>true</code> <code>auth</code> <code>const uint8_t[2]</code> The WiFi authentication method. Default is <code>SFE_ST25DV_WIFI_AUTH_WPA2_PERSONAL</code> = 0x00, 0x20 <code>encrypt</code> <code>const uint8_t[2]</code> The WiFi encryption method. Default is <code>SFE_ST25DV_WIFI_ENCRYPT_AES</code> = 0x00, 0x08 return value <code>bool</code> <code>true</code> if the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_NDEF/#readndefwifi","title":"readNDEFWiFi()","text":"<p>This method reads and returns a single NDEF WiFi record from EEPROM.</p> <p>By default, the first record is returned. The second and subsequent records can be read by setting <code>recordNo</code> to the desired value.</p> <p>If the chosen <code>recordNo</code> is not present, the method returns <code>false</code>. This provides an easy way to count the number of WiFi records in memory.</p> <pre><code>bool readNDEFWiFi(char *ssid, uint16_t maxSsidLen, char *passwd, uint16_t maxPasswdLen, uint8_t recordNo)\n</code></pre> Parameter Type Description <code>ssid</code> <code>char *</code> A pointer to the char array which will hold the SSID <code>maxSsidLen</code> <code>uint16_t</code> The maximum number of bytes which <code>ssid</code> can hold. I.e. the <code>sizeof</code> of <code>ssid</code> <code>passwd</code> <code>char *</code> A pointer to the char array which will hold the password <code>maxPasswdLen</code> <code>uint16_t</code> The maximum number of bytes which <code>passwd</code> can hold. I.e. the <code>sizeof</code> of <code>passwd</code> <code>recordNo</code> <code>uint8_t</code> The URI record to be read. Default is 1 return value <code>bool</code> <code>true</code> if the read is successful (i.e. <code>recordNo</code> exists), <code>false</code> otherwise"},{"location":"api_SFE_ST25DV64KC_NDEF/#writendeftext","title":"writeNDEFText()","text":"<p>This method writes an NDEF Text record to EEPROM.</p> <p>The text passed in <code>const char *theText</code>.</p> <p>Note</p> <p>The length of <code>theText</code> is calculated using <code>strlen</code>, which will fail if <code>theText</code> contains any zero (0x00) bytes. An overloaded method allows the text to be defined using <code>const uint8_t *theText</code> and <code>uint16_t textLength</code> if required.</p> <p>The text language code can be defined using the <code>languageCode</code> parameter. <code>languageCode</code> defaults to <code>NULL</code>, in which case the language code is set automatically to \"en\" (English).</p> <p>Multiple records can be written by: providing an <code>address</code> plus Message Begin (<code>MB</code>) and Message End (<code>ME</code>) flags.</p> <p>If <code>address</code> is provided, it is updated with the memory location after the final one written as part of this record. This allows it to be used as the start address for the next record.</p> <p>A single record has both <code>MB</code> and <code>ME</code> flags set <code>true</code>.</p> <p>The TLV T and L fields are set automatically. The L field is updated from 1-byte to 3-byte automatically if the new record takes the total length beyond 254 bytes.</p> <pre><code>  bool writeNDEFText(const char *theText, uint16_t *address, bool MB, bool ME, const char *languageCode)\n  bool writeNDEFText(const uint8_t *theText, uint16_t textLength, uint16_t *address, bool MB, bool ME, const char *languageCode)\n</code></pre> Parameter Type Description <code>theText</code> <code>const char *</code> A pointer to the text <code>address</code> <code>uint16_t *</code> A pointer to a <code>uint16_t</code> containing the start address for this record. Default is <code>NULL</code>. If not provided, the record is written to <code>_ccFileLen</code> <code>MB</code> <code>bool</code> Message Begin flag. Default is <code>true</code> <code>ME</code> <code>bool</code> Message End flag. Default is <code>true</code> <code>languageCode</code> <code>const char *</code> A pointer to the text language code. Default is <code>NULL</code> return value <code>bool</code> <code>true</code> if the write was successful, otherwise <code>false</code> Parameter Type Description <code>theText</code> <code>const uint8_t *</code> A pointer to the text <code>textLength</code> <code>uint16_t</code> The number of bytes contained in <code>theText</code> <code>address</code> <code>uint16_t *</code> A pointer to a <code>uint16_t</code> containing the start address for this record. Default is <code>NULL</code>. If not provided, the record is written to <code>_ccFileLen</code> <code>MB</code> <code>bool</code> Message Begin flag. Default is <code>true</code> <code>ME</code> <code>bool</code> Message End flag. Default is <code>true</code> <code>languageCode</code> <code>const char *</code> A pointer to the text language code. Default is <code>NULL</code> return value <code>bool</code> <code>true</code> if the write was successful, otherwise <code>false</code>"},{"location":"api_SFE_ST25DV64KC_NDEF/#readndeftext","title":"readNDEFText()","text":"<p>This method reads and returns a single NDEF Text record from EEPROM.</p> <p>By default, the first record is returned. The second and subsequent records can be read by setting <code>recordNo</code> to the desired value.</p> <p>If the chosen <code>recordNo</code> is not present, the method returns <code>false</code>. This provides an easy way to count the number of WiFi records in memory.</p> <p>Note</p> <p>If <code>theText</code> could contain any zero (0x00) bytes, you can use the overloaded method to receive the actual text length. On call, set <code>*textLen</code> to maximum number of bytes which <code>theText</code> can hold. On return, <code>*textLen</code> will contain the actual number of chars read.</p> <pre><code>bool readNDEFText(char *theText, uint16_t maxTextLen, uint8_t recordNo, char *language, uint16_t maxLanguageLen)\nbool readNDEFText(uint8_t *theText, uint16_t *textLen, uint8_t recordNo, char *language, uint16_t maxLanguageLen)\n</code></pre> Parameter Type Description <code>theText</code> <code>char *</code> A pointer to the char array which will hold the text <code>maxTextLen</code> <code>uint16_t</code> The maximum number of bytes which <code>theText</code> can hold. I.e. the <code>sizeof</code> of <code>theText</code> <code>recordNo</code> <code>uint8_t</code> The URI record to be read. Default is 1 <code>language</code> <code>char *</code> A pointer to the char array which could hold the language code. Default is <code>NULL</code> <code>maxLanguageLen</code> <code>uint16_t</code> The maximum number of bytes which <code>language</code> can hold. I.e. the <code>sizeof</code> of <code>language</code>. Default is zero return value <code>bool</code> <code>true</code> if the read is successful (i.e. <code>recordNo</code> exists), <code>false</code> otherwise Parameter Type Description <code>theText</code> <code>uint8_t *</code> A pointer to the array of uint8_t which will hold the text <code>textLen</code> <code>uint16_t *</code> The maximum number of bytes which <code>theText</code> can hold. I.e. the <code>sizeof</code> of <code>theText</code>. On return, contains the number of bytes read <code>recordNo</code> <code>uint8_t</code> The URI record to be read. Default is 1 <code>language</code> <code>char *</code> A pointer to the char array which could hold the language code. Default is <code>NULL</code> <code>maxLanguageLen</code> <code>uint16_t</code> The maximum number of bytes which <code>language</code> can hold. I.e. the <code>sizeof</code> of <code>language</code>. Default is zero return value <code>bool</code> <code>true</code> if the read is successful (i.e. <code>recordNo</code> exists), <code>false</code> otherwise"},{"location":"api_SFE_ST25DV64KC_NDEF/#helper-methods","title":"Helper Methods","text":""},{"location":"api_SFE_ST25DV64KC_NDEF/#geturiprefix","title":"getURIPrefix()","text":"<p>This method returns the URI prefix code at readable text. It is used by <code>readNDEFURI</code> to reconstruct the full URI based on the stored <code>idCode</code>.</p> <pre><code>const char *getURIPrefix(uint8_t prefixCode)\n</code></pre> Parameter Type Description <code>prefixCode</code> <code>uint8_t</code> The prefix code return value <code>const char *</code> A pointer to the prefix as readable text"},{"location":"api_SFE_ST25DV64KC_NDEF/#member-variables","title":"Member Variables","text":"Parameter Type Description <code>_ccFileLen</code> <code>uint16_t</code> The length of the capability container. I.e. the start address for NDEF records"},{"location":"contribute/","title":"Contribute: Help Make This Library Better!","text":"<p>Spot something wrong or which could be improved? Feel free to contribute our open-source software and documentation. </p>"},{"location":"contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun ST25DV64KC Arduino Library repository.</li> </ul>"},{"location":"contribute/#spot-something-wrong","title":"Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"contribute/#submit-a-correction-or-improvement","title":"Submit a Correction or Improvement","text":"<ol> <li>Fork this repo</li> <li>Add your corrections or improvements to the markdown file or source code</li> <li>File a Pull Request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the code and documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our standards.</li> </ul> </li> </ol>"},{"location":"contribute/#contributors","title":"Contributors","text":"<p>Let's provided some recognition to the contributors for this project!</p> <p> </p>"},{"location":"intro/","title":"Introduction","text":"<p>The ST25DV dynamic NFC RFID tag ICs are awesome! The ST25DV64KC offers 64-kBit (8-KBytes) of EEPROM memory which can be accessed over both I<sup>2</sup>C and RF (NFC)!</p> <p>It's a state-of-the-art tag which conforms to ISO/IEC 15693 or NFC Forum Type 5 recommendations.</p> <p>The memory can be divided into four areas, each of which can have different levels of protection applied. Want to store your data so everyone has read and write access over both I<sup>2</sup>C? and RF? You can do that. In fact, that's the default. Want to store your data in an area which can only be read if you know the password, and cannot be written to (via RF)? You can do that too!</p> <p>This library provides all of the methods you need to read and write the user memory, control the read and write permissions, alter the area sizes and apply password control.</p> <p>Not only that! We've included extra methods which will let you read and write NDEF (NFC Forum Data Exchange Format) URI, WiFi and Text records which your smart phone can understand!</p> <p>Do you want your project to be able to log up to 8-kBytes of data (via I<sup>2</sup>C) and then be able to read it using your smart phone - even if your project is powered off? This library lets you do that!</p> <p>Do you want to be able to write WiFi credentials (SSID and Password) into tag memory using your smart phone and then to be able to read them over I<sup>2</sup>C? With this library you can do that too!</p> <p>Do you want to be able to manufacture and test your product and then program it with keys or other credentials just before you ship? We've got you covered.</p> <p>Are you developing equipment or appliances for the home? Would you like to store diagnostic information so that the repair engineer can access it using their smart phone? This library lets you do that!</p> <p>Would you like the customer to be able to read the diagnostics with their smart phone and then email them to you? This library will let you do that too! (Apart from the email bit - obvs.. You will need to add that bit yourself.)</p> <p>The examples in this library have been tested on multiple platforms. We enjoyed writing and testing them. We hope you enjoy them too and that they make your life easier.</p>"},{"location":"software/","title":"Software Setup","text":""},{"location":"software/#installation","title":"Installation","text":"<p>The SparkFun ST25DV64KC Arduino Library is available within the Arduino library manager, which is launched via the <code>Sketch &gt; Include Libraries &gt; Manage Libraries \u2026</code> menu option in the Arduino IDE. Just search for SparkFun ST25DV64KC</p> <p>Note</p> <p>This guide assumes you are using the latest version of the Arduino IDE on your desktop. The following resources available at SparkFun provide the details on setting up and configuring Arduino to use this library.</p> <ul> <li>Installing the Arduino IDE</li> <li>Installing an Arduino Library</li> <li>Installing Board Definitions in the Arduino IDE</li> </ul>"},{"location":"software/#general-use-pattern","title":"General Use Pattern","text":"<p>The SparkFun ST25DV64KC Arduino Library includes a comprehensive set of examples which show, step by step, how to use the library and exchange data with the ST25DV tag. The examples are available from the Examples menu of the Arduino IDE, and in the <code>examples</code> folder of this repository. </p> <p>For a detailed walk-through of each example, please see the Examples section of the documentation.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_01_Device_Information/","title":"Example 1 - Device Information","text":"<p>A simple example to show the basic setup and use of SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_01_Device_Information/#key-features","title":"Key Features","text":"<ul> <li>Declaring a SFE_ST25DV64KC tag object</li> <li>Beginning communication with the tag over I<sup>2</sup>C</li> <li>Reading the tag's Unique Identifier (UID)</li> <li>Reading the tag's Device Revision</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_01_Device_Information/#setup","title":"Setup","text":"<p>After installing this library in your local Arduino environment, begin with a standard Arduino sketch and include the header file for this library:</p> <pre><code>#include &lt;SparkFun_ST25DV64KC_Arduino_Library.h&gt; // Click here to get the library:  http://librarymanager/All#SparkFun_ST25DV64KC\n</code></pre> <p>The next step is to declare the ST25DV64KC object. Like most Arduino sketches, this is done at a global scope (after the include file declaration), not within the <code>setup()</code> or <code>loop()</code> functions. </p> <p>Select one of the following classes:</p> Class Description <code>SFE_ST25DV64KC</code> This is the core class - it provides read and write methods to access the tag's EEPROM memory <code>SFE_ST25DV64KC_NDEF</code> This class provides additional methods to read and write NDEF URI, WiFi and Text records <p>For this example, the SFE_ST25DV64KC class is used as we don't yet need access to the NDEF methods.</p> <pre><code>SFE_ST25DV64KC tag;\n</code></pre> <p>The later examples show how to use the NDEF methods. If you want to use those methods, the declaration becomes:</p> <pre><code>SFE_ST25DV64KC_NDEF tag;\n</code></pre>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_01_Device_Information/#initialization","title":"Initialization","text":"<p>In the <code>setup()</code> function of this sketch, we need to:</p> <ul> <li>Start <code>Wire</code> (I<sup>2</sup>C) communication</li> <li>Begin communication with the tag to ensure it is connected</li> </ul> <pre><code>void setup()\n{\n  delay(1000);\n\n  Serial.begin(115200); // Start Serial (UART) communication\n\n  Wire.begin(); // Start I2C communication\n\n  Serial.println(F(\"ST25DV64KC example.\"));\n\n  if (!tag.begin(Wire)) // Begin communication with the tag using the Wire port\n  {\n    Serial.println(F(\"ST25 not detected. Freezing...\"));\n    while (1) // Do nothing more\n      ;\n  }\n\n  Serial.println(F(\"ST25 connected.\"));\n</code></pre> <p>The <code>begin</code> method tells the SFE_ST25DV64KC object that it is connected via the I<sup>2</sup>C port called <code>Wire</code>. If your board supports multiple ports, you could (e.g.) replace <code>Wire</code> with <code>Wire1</code> as appropriate.</p> <p>If you call <code>begin</code> without naming a I<sup>2</sup>C port, the object assumes you are using <code>Wire</code>.</p> <p>The <code>begin</code> method returns true if the ST25DV is connected. If it returns false, we know no device is connected and - in this simple example - the code will freeze at that point.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_01_Device_Information/#reading-the-unique-identifier","title":"Reading the Unique Identifier","text":"<p>Each tag is pre-programmed with a unique 8-byte (64-bit) identifier which conforms to ISO/IEC 15693.</p> <p>Not all platforms support the printing of 64-bit numbers so we: create an array of eight bytes to hold the UID; read the UID using <code>getDeviceUID</code>; and print it one byte at a time in hexadecimal format.</p> <pre><code>  uint8_t values[8] = {0};\n\n  if (tag.getDeviceUID(values)) // Read the Unique Identifier\n  {\n    Serial.print(F(\"Device UID: \"));\n    for (uint8_t i = 0; i &lt; 8; i++) // Print the UID in HEX format\n    {\n      if (values[i] &lt; 0x0a) // Add a leading zero if required\n        Serial.print(F(\"0\"));\n      Serial.print(values[i], HEX);\n      Serial.print(F(\" \"));\n    }\n    Serial.println();\n  }\n  else\n    Serial.println(F(\"Could not read device UID!\"));\n</code></pre> <p>Like <code>begin</code>, <code>getDeviceUID</code> will return false if an error occurs. In this example, we print a warning message (\"Could not read device UID!\") if that happens.</p> <p>It is fun to read the tag's identifier using ST's \"NFC Tap\" App on your smart phone and compare it to the UID printed by this example. You will find they are exactly the same. You can find \"NFC Tap\" in the Apple App Store and Google Play. Open the App, hit \"Scan\" and then \"Read Tag\". Hold your phone over the tag and the Tag Information will appear. On iPhones, the NFC reader is at the 'top' of the phone, near the cameras.</p> <p> NFC Tap images. (Click to enlarge) </p> <p></p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_01_Device_Information/#reading-the-tag-revision","title":"Reading the Tag Revision","text":"<p>Each tag is also programmed with a version number, indicating what version of hardware is inside the tag IC. We can read that using <code>getDeviceRevision</code> as follows:</p> <pre><code>  uint8_t rev;\n  if (tag.getDeviceRevision(&amp;rev)) // Read the Device Revision\n  {\n    Serial.print(F(\"Revision: \"));\n    Serial.println(rev); // Print it in decimal format\n  }\n  else\n    Serial.println(F(\"Could not read device revision!\"));\n}\n</code></pre> <p>Again, <code>getDeviceRevision</code> will return false if an error occurs. If that happens, the \"Could not read device revision!\" warning is printed.</p> <p>And that's all folks! There is no code inside <code>loop()</code> in this example.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/","title":"Example 2 - Memory Read Write Operations","text":"<p>A more complex example showing how to read and write the tag's EEPROM memory using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/#key-features","title":"Key Features","text":"<ul> <li>Opening a I<sup>2</sup>C Security Session using the password</li> <li>Reading and changing the memory read and write protection</li> <li>Reading memory</li> <li>Writing to memory</li> <li>Demonstrating how the password can control writing</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/#tag-memory","title":"Tag Memory","text":"<p>The ST25DV64KC has 64-kBits of EEPROM user memory. That's 8-kBytes or 8192 Bytes. We can use all of that memory to store data.</p> <p>The ST25DV tags are \"dynamic\". The memory can be read and written to using both I<sup>2</sup>C and RF (NFC). For I<sup>2</sup>C, the tag needs to be powered up via your Arduino board. But for RF, the tag memory can be read and written to even when the tag is powered off. The RF field provides the power.</p> <p>By default, the memory can be both read and written using both I<sup>2</sup>C and RF. We do not need to enter a password for either interface. But it is possible to change that using the tag's read and write protection settings. There are independent settings for I<sup>2</sup>C and RF.</p> <p>The tag's memory can also be divided up into four areas. By default, Area 1 occupies the whole 8-kBytes of memory and Areas 2-4 are zero length. Example 4 demonstrates how to change the size of the areas.</p> <p>Area 1 is special in that it is always readable. We can only change its write permission. Areas 2-4 can be both read and write protected.</p> <p>If we enable the I<sup>2</sup>C write protection for Area 1, we need to enter a password before we can write to Area 1. Remember that Area 1 is always readable.</p> <p>The default password is eight zero bytes: 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00. Example 3 shows how to change the password.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/#entering-the-password","title":"Entering The Password","text":"<p>Example 2 starts by beginning communication with the tag. It then enters the I<sup>2</sup>C password so we can change the write protection.</p> <p>By default, we do not need to enter a password to write data to Area 1. Write protection is disabled by default. But we do need to enter the password to be able to change the write protection.</p> <p>ST use the term \"Security Session\" to describe the time when the password has been entered and we can make changes to the tag's security settings.</p> <p>The example opens a security session by calling <code>openI2CSession</code> and providing the password:</p> <pre><code>  Serial.println(F(\"Opening I2C security session with default password (all zeros).\"));\n  uint8_t password[8] = {0x0}; // Default password is all zeros\n  tag.openI2CSession(password); // Enter the password\n</code></pre> <p>The example then checks if the password has been entered correctly by calling <code>isI2CSessionOpen</code>:</p> <pre><code>  Serial.print(F(\"I2C session is \"));\n  Serial.println(tag.isI2CSessionOpen() ? \"opened.\" : \"closed.\");\n</code></pre>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/#checking-read-and-write-protection","title":"Checking Read and Write Protection","text":"<p>The example checks if Area 1 is read-protected by calling <code>getEEPROMReadProtectionBit(1)</code>. Remember that Area 1 is always readable.</p> <pre><code>  Serial.println(F(\"EEPROM area 1 will always be readable (datasheet page 60).\"));\n  Serial.print(F(\"EEPROM area 1 read protection: \"));\n  Serial.println(tag.getEEPROMReadProtectionBit(1) ? \"protected.\" : \"opened.\");\n</code></pre> <p><code>getEEPROMReadProtectionBit</code> returns true if read protection is enabled and false if not.</p> <p>If we wanted to check Area 2, we would call <code>getEEPROMReadProtectionBit(2)</code>.</p> <p>The example uses shorthand - <code>?</code> and <code>:</code> - to print \"protected\" and \"opened\". It is exactly the same as:</p> <pre><code>  if (tag.getEEPROMReadProtectionBit(1))\n     Serial.println(\"protected.\");\n  else\n    Serial.println(\"opened.\");\n</code></pre> <p>The example then checks the write protection by calling <code>getEEPROMWriteProtectionBit</code>:</p> <pre><code>  Serial.print(F(\"EEPROM area 1 write protection: \"));\n  Serial.println(tag.getEEPROMWriteProtectionBit(1) ? \"protected.\" : \"opened.\");\n</code></pre>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/#changing-the-write-protection","title":"Changing the Write Protection","text":"<p>Remember that, by default, Area 1 is not write-protected. Writing is \"open\". We do no need to enter a password to write to Area 1. But we do need to enter the password to change the write-protection.</p> <p>We can enable write protection for Area 1 by calling <code>programEEPROMWriteProtectionBit</code>.</p> <p><code>programEEPROMWriteProtectionBit(1, true)</code> sets the write protection bit for Area 1.</p> <pre><code>  Serial.println(F(\"Protecting area 1 for write operation.\"));\n  tag.programEEPROMWriteProtectionBit(1, true);\n\n  bool area1WriteProtected = tag.getEEPROMWriteProtectionBit(1);\n  Serial.print(F(\"EEPROM area 1 write protection: \"));\n  Serial.println(area1WriteProtected ? \"protected.\" : \"opened.\");\n  if (area1WriteProtected)\n    Serial.println(F(\"Writing can only take place if I2C security session is opened.\"));\n</code></pre> <p>Now that write protection is enabled, we can only write to Area 1 if we have entered the password.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/#memory-read","title":"Memory Read","text":"<p>We read the tag's EEPROM memory by calling <code>readEEPROM</code>:</p> <pre><code>  // Read 16 bytes from EEPROM location 0x0\n  uint8_t tagRead[16] = {0}; // Create storage to hold the tag read\n  Serial.print(F(\"Reading values, starting at location 0x0, with opened security session:        \"));\n  tag.readEEPROM(0x00, tagRead, 16); // Read the EEPROM: start at address 0x0; read contents into tagRead; read 16 bytes\n</code></pre> <p>The code creates an array of <code>uint8_t</code> (unsigned 8-bit bytes) to hold the memory contents.</p> <p>The code then reads the first 16 memory locations using <code>readEEPROM</code>:</p> <ul> <li>The <code>0x00</code> tells the method to start at address zero.</li> <li>The contents will be written into the array <code>tagRead</code></li> <li>Exactly <code>16</code> bytes will be read</li> </ul> <p>The example then prints the memory contents in hexadecimal format, like we did with the UID in Example 1.</p> <pre><code>  for (auto value : tagRead) // Print the contents\n  {\n    Serial.print(F(\"0x\"));\n    if (value &lt; 0x10)\n      Serial.print(F(\"0\")); // Add a leading zero if required\n    Serial.print(value, HEX); // Print the contents in HEX format\n    Serial.print(F(\" \"));\n  }\n  Serial.println();\n</code></pre> <p>The <code>for (auto value : tagRead)</code> is more code shorthand. It is exactly the same as writing:</p> <pre><code>  for (uint8_t value = 0; value &lt; sizeof(tagRead); value++)\n</code></pre>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/#memory-write","title":"Memory Write","text":"<p>Now the fun part! The example writes 16 random bytes to the first 16 memory locations:</p> <pre><code>  // Try to write 16 random bytes to EEPROM starting at location 0x0\n  uint8_t tagWrite[16]; // Create storage to hold the data to be written\n  randomSeed(analogRead(A0));\n  for (uint8_t i = 0; i &lt; 16; i++) // Generate 16 random values and store them in tagWrite\n    tagWrite[i] = (uint8_t)random(0, 0xff);\n\n  Serial.print(F(\"Writing random values, starting at location 0x0, with opened security session: \"));\n  // ...\n  Serial.println();\n  tag.writeEEPROM(0x00, tagWrite, 16); // Write data to EEPROM: start at address 0x0; use the data in tagWrite; write 16 bytes\n</code></pre> <p>The code creates 16 random values and puts them into an array called <code>tagWrite</code>. The actual writing is performed by <code>writeEEPROM</code>:</p> <ul> <li>The <code>0x00</code> tells the method to start at address zero.</li> <li>Write the data in the array <code>tagWrite</code></li> <li>Exactly <code>16</code> bytes will be written</li> </ul> <p>The code then reads those 16 bytes back again, just to prove they have been written correctly:</p> <p> Arduino IDE Serial Monitor output for Example 2. (Click to enlarge) </p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/#closing-the-security-session","title":"Closing the Security Session","text":"<p>Remember that we enabled Area 1 write protection earlier in the example. We can only write data to Area 1 if we have opened a security session by entering the correct password.</p> <p>We can close the security session by entering the wrong password:</p> <pre><code>  Serial.println(F(\"Closing I2C security session - by writing the wrong password.\"));\n  password[1] = {0x10}; // Change one byte of the password\n  tag.openI2CSession(password);\n\n  Serial.print(F(\"I2C session is \"));\n  Serial.println(tag.isI2CSessionOpen() ? \"opened.\" : \"closed.\");\n</code></pre> <p>It does not matter what password we enter, so long as it is not the current password (all zeros).</p> <p>If we try to write data to Area 1 now, the write is rejected and the memory is not changed:</p> <p> Arduino IDE Serial Monitor output for Example 2. (Click to enlarge) </p> <p>We can not change the write protection either because the security session is closed.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_02_Memory_Read_Write/#changing-the-write-protection-again","title":"Changing the Write Protection (Again)","text":"<p>The example concludes by doing the following:</p> <ul> <li>The correct password is entered using <code>openI2CSession</code></li> <li>Area 1 write protection is turned off using <code>programEEPROMWriteProtectionBit</code></li> <li>The security session is closed by entering the wrong password</li> <li>The random data we wrote earlier is overwritten with zeros</li> </ul> <p>This leaves the tag in its default state: write protection is not enabled; and the first 16 memory locations are all zero</p> <p> Arduino IDE Serial Monitor output for Example 2. (Click to enlarge) </p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_03_I2C_Password/","title":"Example 3 - I2C Password","text":"<p>An example showing how to change the I<sup>2</sup>C password using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_03_I2C_Password/#key-features","title":"Key Features","text":"<ul> <li>Opening a I<sup>2</sup>C Security Session using the password</li> <li>Changing the I<sup>2</sup>C password</li> <li>Demonstrating how the password can control writing</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_03_I2C_Password/#changing-the-password","title":"Changing The Password","text":"<p>Example 2 demonstrated how the I<sup>2</sup>C password can be used to open a security session, so the tag's settings - like write protection - can be changed.</p> <p>Remember that:</p> <ul> <li>Area 1 can always be read. There is no read protection on Area 1</li> <li>By default, Area 1 is not write-protected</li> <li>We can only change the write protection by opening a security session using the correct password</li> <li>The default password is all zeros ( 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )</li> </ul> <p>Same as Example 2, this example begins by opening a security session using the default password and enabling write-protection on Area 1. Area 1 can then only be modified if the correct password has entered.</p> <p>Example 3 then demonstrates how to change the I<sup>2</sup>C password using <code>writeI2CPassword</code>. As you would expect, we can only change the password having first entered the correct password to open a security session.</p> <pre><code>  Serial.println(F(\"Changing the I2C password to 0x0123456789ABCDEF.\"));\n  uint8_t newPassword[8] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };\n  tag.writeI2CPassword(newPassword);\n  Serial.print(F(\"I2C session is \"));\n  Serial.println(tag.isI2CSessionOpen() ? \"opened.\" : \"closed.\");\n</code></pre> <p>Attention</p> <p>The password can be read back from the tag, but only when a security session is open. If you change the password, close the security session and then forget the password, your tag is locked forever. There is no way to change or reset the pasword unless you know the password. If you change it, write it down somewhere!</p> <p>Like Example 2, Example 3 goes on to demonstrate that by entering the wrong password (all zeros in this case) the memory can not then be changed - because write protection is enabled.</p> <p>The example cleans up after itself by:</p> <ul> <li>Re-entering the new password</li> <li>Changing the password back to all zeros</li> <li>Turning off write protection</li> <li>Closing the security session</li> <li>Writing zeros to the first 16 memory locations</li> </ul> <p> Arduino IDE Serial Monitor output for Example 3. (Click to enlarge) </p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_04_Memory_End_Address/","title":"Example 4 - Memory End Addresses","text":"<p>An example showing how to configure the user memory areas using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_04_Memory_End_Address/#key-features","title":"Key Features","text":"<ul> <li>Opening a I<sup>2</sup>C Security Session using the password</li> <li>Changing the size of Area 1 by changing its end address</li> <li>Attempting to change the size of Area 2 using an invalid end address</li> <li>Changing the size of Area 1 back to the default</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_04_Memory_End_Address/#changing-area-1","title":"Changing Area 1","text":"<p>We mentioned back in Example 2 that the ST25DV64KC user memory can be divided up into four areas. By default, Area 1 occupies the full 8-kBytes of memory.</p> <p>The size of the four areas can be changed by changing their end addresses. By default, all four end addresses on the ST25DV64KC are the same:</p> Area End Address End Address (Hex) End Address (Decimal) <code>1</code> ENDA1 0x1FFF 8191 <code>2</code> ENDA2 0x1FFF 8191 <code>3</code> ENDA3 0x1FFF 8191 <code>4</code> ENDA4 0x1FFF 8191 <p>Area 1 always starts at location zero, so by having all four end addresses the same, Areas 2-4 are actually zero length. Area 2 starts where Area 1 ends and so on.</p> <p>This library will work with smaller ST25DV devices. For the ST25DV04KC, the memory is 4-kBits which is 512 Bytes. Its Area 1 end address (ENDA1) is 0x01FF.</p> <p>Note</p> <p>When accessing the memory via the RF interface, the memory is read and written in blocks of four bytes. The last user memory block address, seen by RF, for the ST25DV64KC is 0x07FF. It is still possible to access the full memory via the RF interface.</p> <p>It can be useful to change the memory area sizes so that different security levels can be applied to each. Remember that Area 1 is always readable, but can be write-protected. For Areas 2-4, it is possible to apply read-protection. It is also possible to apply different security levels for the I<sup>2</sup>C and RF interfaces for each area.</p> <p>Example 4 changes the size of Area 1 by calling <code>setMemoryAreaEndAddress</code>.</p> <p>The end address is defined using a single byte. The true end address is: (32 * ENDA) + 31</p> <p>For Area 1, the default value of ENDA1 is actually 0xFF (Hexadecimal) or 255 (Decimal):</p> <p>(32 * 255) + 31 = 8191</p> <p>The area sizes can only be changed in increments of 32 bytes. The minimum size for Area 1 is 32 bytes (when ENDA1 is zero).</p> <p>Remember that we need to open a security session first, before we attempt to change the end addresses.</p> <p>Example 4 changes the Area 1 end address to 0x021F by calling <code>setMemoryAreaEndAddress(1, 0x10)</code>. It reads back the new end address by calling <code>getMemoryAreaEndAddress</code>.</p> <pre><code>  // Change the Area 1 end address:\n  // This function will succeed if ENDA1 value is less than or equal to ENDA2 and ENDA3.\n  // Further information can be found in the datasheet on page 14.\n  // Memory address will be: 0x20 * ENDAi + 0x1f which in this case results\n  // in 0x20 * 0x10 + 0x1f = 0x021f\n  Serial.println(F(\"Trying to change the Area 1 end address to 0x021F.\"));\n  if (tag.setMemoryAreaEndAddress(1, 0x10))\n  {\n    Serial.println(F(\"Success setting Area 1 end address.\"));\n  }\n  else\n  {\n    Serial.println(F(\"Error setting Area 1 end address.\"));\n  }\n\n  memset(endAddress, 0, 5);\n\n  Serial.print(F(\"Area 1 end address is now 0x\"));\n  sprintf(endAddress, \"%04x\", tag.getMemoryAreaEndAddress(1)); // Get the area 1 end address. Print it into endAddress in HEX format\n  Serial.println(endAddress); // Print it\n</code></pre> <p>Area 1 now occupies addresses 0x0000 to 0x021F. Area 2 now occupies addresses 0x0220 to 0x1FFF. Areas 3 and 4 are still zero size.</p> <p>Just to prove that it is not possible, the example then tries to set the Area 2 end address to less than 0x021F. This fails as the areas cannot 'overlap'. ENDA2 must always be greater than or equal to ENDA1.</p> <pre><code>  // Change the Area 2 end address:\n  // This function will fail since ENDA2 value is less than the ENDA1 programmed above.\n  // Further information can be found on the datasheet on page 14.\n  // Memory address will be: 0x20 * ENDAi + 0x1f which in this case results\n  // in 0x20 * 0x03 + 0x1f = 0x007f\n  Serial.println(F(\"Trying to change the Area 2 end address to 0x007F. (This will fail!)\"));\n  if (tag.setMemoryAreaEndAddress(2, 0x03))\n  {\n    Serial.println(F(\"Success setting Area 2 end address.\"));\n  }\n  else\n  {\n    Serial.println(F(\"Error setting Area 2 end address.\"));\n  }\n\n  memset(endAddress, 0, 5);\n\n  Serial.print(F(\"Area 2 end address is 0x\"));\n  sprintf(endAddress, \"%04x\", tag.getMemoryAreaEndAddress(2));\n  Serial.println(endAddress);\n</code></pre> <p>The example finishes by restoring ENDA1 back to 0x1FFF:</p> <pre><code>  // Restore ENDA1:\n  // This function will succeed if ENDA1 value is less than or equal to ENDA2 and ENDA3.\n  // Further information can be found on the datasheet on page 14.\n  // Memory address will be: 0x20 * ENDAi + 0x1f which in this case results\n  // in  0x20 * 0xff + 0x1f = 0x1fff\n  Serial.println(F(\"Trying to change the Area 1 end address to 0x1FFF.\"));\n  if (tag.setMemoryAreaEndAddress(1, 0xFF))\n  {\n    Serial.println(F(\"Success setting Area 1 end address.\"));\n  }\n  else\n  {\n    Serial.println(F(\"Error setting Area 1 end address.\"));\n  }\n\n  memset(endAddress, 0, 5);\n\n  Serial.print(F(\"Area 1 end address is now 0x\"));\n  sprintf(endAddress, \"%04x\", tag.getMemoryAreaEndAddress(1));\n  Serial.println(endAddress);\n</code></pre> <p> Arduino IDE Serial Monitor output for Example 4. (Click to enlarge) </p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_05_RF_Field_Poll/","title":"Example 5 - RF Field Detection (using Polling)","text":"<p>An example showing how to detect an RF field (using polling) using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_05_RF_Field_Poll/#key-features","title":"Key Features","text":"<ul> <li>Detecting an RF Field</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_05_RF_Field_Poll/#detecting-an-rf-field","title":"Detecting an RF Field","text":"<p>Example 5 is very simple. It does not need to open a security session as it is not changing any of the tag settings. It simply polls whether an RF field is present using <code>RFFieldDetected</code>. It does this inside the <code>loop()</code> so the code repeats automatically.</p> <p>In this example, we poll the RF field every 250ms. The RF tag detection by your smart phone can be very fast. So don't be surprised if you only see one or two detections each time your bring your phone near the tag. You can generate a field for longer if you use the \"NFC Tap\" App to read the tag's memory.</p> <pre><code>void loop()\n{\n  bool value = tag.RFFieldDetected();\n  if (value)\n    Serial.println(F(\"RF field detected.\"));\n  else\n    Serial.println(F(\"RF field not detected.\"));\n\n  delay(250);\n}\n</code></pre> <p>The next example shows how to use interrupts for field detection.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_06_RF_Field_Interrupt/","title":"Example 6 - RF Field Detection (using Interrupts)","text":"<p>An example showing how to detect an RF field (using interrupts) using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_06_RF_Field_Interrupt/#key-features","title":"Key Features","text":"<ul> <li>Opening a security session</li> <li>Configuring the tag's GPO pin for RF detection</li> <li>Using Arduino interrupts to detect the field</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_06_RF_Field_Interrupt/#gpo-pin","title":"GPO Pin","text":"<p>The ST25DV has a very useful GPO (General Purpose Output) pin. It can be configured in a number of different ways.</p> <p>This example configures GPO to indicate the presence of an RF field. We can then use the signal on GPO to trigger an interrupt on our Arduino board.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_06_RF_Field_Interrupt/#arduino-interrupts","title":"Arduino Interrupts","text":"<p>There are many good tutorials out there showing how to use Arduino interrupts. Here is a brief summary of how it is done in this example:</p> <pre><code>// Use a jumper cable to link the ST25DV64KC GPO1 pin to a digital pin\nconst uint8_t GPO_PIN = 2; // Change this to match the digital pin you have linked GPO1 to\n\nstatic volatile bool interruptChanged = false;\n\nvoid myISR() // Interrupt Service Routine\n{\n  interruptChanged = true;\n}\n</code></pre> <p>This code creates <code>interruptChanged</code> as a static volatile boolean variable, and sets it to false.</p> <p><code>static</code> means it is always present in memory. It is never deleted or destroyed. This is actually redundant because <code>interruptChanged</code> is global but we include it for clarity. (If we had created <code>interruptChanged</code> in the <code>loop()</code> then the static would be very important.)</p> <p><code>volatile</code> means that <code>interruptChanged</code> could change at any moment - when an interrupt occurs - and so the compiler should always read <code>interruptChanged</code> directly and not use any kind of local copy for speed.</p> <p><code>myISR()</code> is our interrupt service routine. It is the small piece of code which is called when the interrupt takes place. There are some 'golden rules' when writing ISRs:</p> <ul> <li>Always keep them short</li> <li>Always use <code>volatile</code> variables if they need to be accessed by code in the <code>loop()</code></li> <li>Don't try to do anything time consuming inside them - always keep them short</li> <li>Don't ever use Serial prints inside ISRs</li> </ul> <p>In <code>setup()</code>, GPO_PIN (Digital Pin 2) is configured to create the interrupt:</p> <pre><code>  pinMode(GPO_PIN, INPUT);\n  attachInterrupt(digitalPinToInterrupt(GPO_PIN), myISR, CHANGE);\n</code></pre> <p>Now <code>myISR</code> will be called whenever pin 2 changes state.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_06_RF_Field_Interrupt/#gpo-pin_1","title":"GPO Pin","text":"<p>We need to link the tag's GPO breakout pad to Pin 2 on our Arduino board. You may want to solder header pins onto the tag breakout and then use a jumper cable to connect them.</p> <p>Pin 2 is an interrupt pin on our original Uno-like RedBoards (ATMega328P). You can change the pin number to any other interrupt-capable pin if needed.</p> <p>The example goes on to configure the GPO pin using <code>setGPO1Bit</code>. Remember that we can only change the tag's settings if a security session has been opened.</p> <pre><code>  Serial.println(F(\"Configuring GPO1 to toggle on field change only.\"));\n  tag.setGPO1Bit(BIT_GPO1_FIELD_CHANGE_EN, true);\n  Serial.println(F(\"Disabling other bits.\"));\n  tag.setGPO1Bit(BIT_GPO1_RF_USER_EN, false);\n  tag.setGPO1Bit(BIT_GPO1_RF_ACTIVITY_EN, false);\n  tag.setGPO1Bit(BIT_GPO1_RF_INTERRUPT_EN, false);\n  tag.setGPO1Bit(BIT_GPO1_RF_PUT_MSG_EN, false);\n  tag.setGPO1Bit(BIT_GPO1_RF_GET_MSG_EN, false);\n  tag.setGPO1Bit(BIT_GPO1_RF_WRITE_EN, false);\n\n  Serial.println(F(\"Enabling GPO_EN bit.\"));\n  tag.setGPO1Bit(BIT_GPO1_GPO_EN, true);\n</code></pre> <p>You can see from the code that GPO can be configured to do many different things. In this example we only want it to change when the RF field changes, so we only set the <code>BIT_GPO1_FIELD_CHANGE_EN</code> bit to true. All the other bits are set to false.</p> <p>We also need to actually enable the GPO pin with <code>BIT_GPO1_GPO_EN</code>.</p> <p>You can guess from the bit names that it is possible to use GPO to indicate other events, such as an RF write taking place.</p> <p>Run the example and bring your phone near to the tag. You will see the count increase rapidly each time an NFC transfer takes place.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_07_Energy_Harvesting/","title":"Example 7 - Energy Harvesting","text":"<p>An example showing how to enable the ST25DV's energy harvesting feature using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_07_Energy_Harvesting/#key-features","title":"Key Features","text":"<ul> <li>Enabling energy harvesting</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_07_Energy_Harvesting/#energy-harvesting","title":"Energy Harvesting","text":"<p>The ST25DV can harvest small amounts of power when an RF field is present.</p> <p>Only small amounts of power can be generated. Perhaps enough to charge a small super capacitor to power a very low-power microcontroller.</p> <p>By default, energy harvesting is \"on demand only\" (when the EH_EN bit is set). If the power is removed, harvesting is automatically disabled.</p> <p>It is possible to configure the tag so energy harvesting is always enabled after boot (if possible) by setting the EH_MODE bit.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_07_Energy_Harvesting/#enable-eh","title":"Enable EH","text":"<p>To enable energy harvesting, Example 7 opens a security session and then sets the EH_EN bit. A voltage is then produced on the EH breakout pin whenever an RF field is present.</p> <pre><code>  tag.setEH_CTRL_DYNBit(BIT_EH_CTRL_DYN_EH_EN, true);\n</code></pre> <p>Attention</p> <p>The voltage on the EH pin could be higher than 3.3V. Take care if you are using a microcontroller analog pin to measure the voltage.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_08_NDEF_URI/","title":"Example 8 - NDEF URI","text":"<p>An example showing how to create an NDEF URI record using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_08_NDEF_URI/#key-features","title":"Key Features","text":"<ul> <li>Writing the tag's Capability Container (CC)</li> <li>Writing an NDEF URI record</li> <li>Reading an NDEF URI record</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_08_NDEF_URI/#nfc-forum-type-5-tag-and-ndef","title":"NFC Forum Type 5 Tag and NDEF","text":"<p>From the ST website:</p> <p>\"Near Field Communication (NFC) Type 5 tags (T5T) and labels operate in the high-frequency (HF) 13.56 MHz range and comply with the NFC-V Technology specification from the NFC Forum. The data stored in these Type 5 tags and labels is transferred to NFC smartphones or professional NFC/RFID HF readers that support the NFC Forum standardized NFC Data Exchange Format (NDEF).\"</p> <p>\"ST25 Type 5 Tag chips are certified by the NFC Forum and comply with the industrial ISO/IEC 15693 RFID specifications, providing interoperability across NFC implementations in NFC smartphones and NFC/RFID HF readers.\"</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_08_NDEF_URI/#creating-a-capability-container","title":"Creating a Capability Container","text":"<p>Up until now, the library examples have been writing 'unformatted data' to the tag's memory. To allow the data to be read and understood by the NFC App on your smart phone, we need to write the data in NFC Data Exchange Format (NDEF).</p> <p>To begin, we need to write a Capability Container at the very start of the tag's memory (Address 0x0000). This is an 8-byte (or 4-byte) number which describes the tag's version, access condition and encoded memory length.</p> <p>For the 8-kByte ST25DV64KC, the CC is set to:</p> <ul> <li>E2 40 00 01 00 00 04 00h to work properly with smartphone</li> <li>E2 40 00 01 00 00 03 FFh for NFC Forum certification</li> </ul> <p>This library defaults to using the NFC Forum value:</p> <pre><code>/*\n  The Capacity Container File is written to the first eight bytes of user memory:\n\n  0xE2 0x40 0x00 0x01 0x00 0x00 0x03 0xFF\n\n  Byte 0: Magic Number\n          The ST25DV64KC has 8kBytes of user memory so we need to select 0xE2 to select two-byte addressing\n  Byte 1: Version and Access Condition\n          b7 b6 = 0b01 Major Version\n          b5 b4 = 0b00 Minor Version\n          b3 b2 = 0x00 Read Access: Always\n          b1 b0 = 0x00 Write Access: Always\n  Byte 2: 0x00\n  Byte 3: Additional Feature Information\n          b7 b6 b5 = 0b000 RFU (Reserved Future Use)\n          b4 = 0b0 Special Frame\n          b3 = 0b0 Lock Block\n          b2 b1 = 0b00 RFU\n          b0 = 0b1 MBREAD: Read Multiple Block is supported\n  Byte 4: 0x00 RFU (Reserved Future Use)\n  Byte 5: 0x00 RFU (Reserved Future Use)\n  Byte 6 + Byte 7: MLEN Encoded Memory Length\n          MLEN = T5T_Area / 8\n          MLEN encoding for a ST25DV64K (8192 bytes memory size) and 8 bytes capability container (CC):\n          If the entire user memory full, user memory is used to store NDEF, T5T_Area=8192-8\n          MLEN = (8192 \u2013 8) / 8 = 1023 (0x03FF)\n*/\n</code></pre> <p>Example 8 begins by clearing the tag's memory, just in case it contains any 'old' information. This is done with <code>writeEEPROM</code> - see Example 2 for more details.</p> <p>The default Capability Container is written by calling <code>writeCCFile8Byte()</code>:</p> <pre><code>  // Write the Type 5 CC File - eight bytes - starting at address zero\n  Serial.println(F(\"Writing CC_File\"));\n  tag.writeCCFile8Byte();\n</code></pre> <p>If you want to use a non-standard CC, you can define your own e.g. by calling:</p> <pre><code>  tag.writeCCFile8Byte( 0xE2400001, 0x00000400 );\n</code></pre> <p>If you are using a small tag, like the ST25DV04K, you could call:</p> <pre><code>  // Write the Type 5 CC File - four bytes - starting at address zero\n  Serial.println(F(\"Writing CC_File\"));\n  tag.writeCCFile4Byte();\n</code></pre> <p>To write a non-standard CC to the ST25DV04K, you could call:</p> <pre><code>  tag.writeCCFile4Byte( 0xE1404000 );\n</code></pre>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_08_NDEF_URI/#creating-an-ndef-uri-record","title":"Creating an NDEF URI Record","text":"<p>Now that the T5T CC has been written, we can start adding NDEF records.</p> <p>One of the most useful records is the Well-Known Uniform Resource Identifier (URI) which covers web address URLs (Uniform Reference Locator).</p> <p>If we want to write a single URI into the tag, we can simply call:</p> <pre><code>    tag.writeNDEFURI(\"sparkfun.com\", SFE_ST25DV_NDEF_URI_ID_CODE_HTTPS_WWW);\n</code></pre> <p>This writes the URI <code>https://www.sparkfun.com</code> in shorthand format using the HTTPS WWW ID Code to save memory.</p> <p>We could have called:</p> <pre><code>    tag.writeNDEFURI(\"https://www.sparkfun.com\", SFE_ST25DV_NDEF_URI_ID_CODE_NONE);\n</code></pre> <p>but the first way is more memory-efficient. <code>SFE_ST25DV_NDEF_URI_ID_CODE_NONE</code> is the default ID Code, so we could have simply called:</p> <pre><code>    tag.writeNDEFURI(\"https://www.sparkfun.com\");\n</code></pre> <p><code>writeNDEFURI</code> does all of the heavy lifting for us. It formats the NDEF data correctly, adding:</p> <ul> <li>The NDEF Message Type Field</li> <li>The Length Field - correctly formatted as 1-Byte or 3-Bytes as appropriate</li> <li>The Header, Length and Payload data for the URI Value itself</li> <li>The Terminator</li> </ul> <pre><code>/*\n  To create a single NDEF URI short record:\n\n  0x03 0x11 0xD1 0x01 0x0D 0x55 0x02 sparkfun.com 0xFE\n\n  Byte 0: Type5 Tag TLV-Format: T (Type field)\n          0x03 = NDEF Message TLV\n  Byte 1: Type5 Tag TLV-Format: L (Length field) (1-Byte Format)\n          0x11 = 17 Bytes\n  Bytes 2-18: Type5 Tag TLV-Format: V (Value field)\n          Byte 2: Record Header = 0xD1\n                  b7 = 0b1 MB (Message Begin)\n                  b6 = 0b1 ME (Message End)\n                  b5 = 0b0 CF (Chunk Flag)\n                  b4 = 0b1 SR (Short Record)\n                  b3 = 0b0 IL (ID Length)\n                  b2 b1 b0 = 0b001 TNF (Type Name Format): NFC Forum Well-Known Type\n          Byte 3: Type Length\n                  0x01 = 1 Byte\n          Byte 4: Payload Length\n                  0x0D = 13 bytes\n          Byte 5: Record Type\n                  0x55 = \"U\" URI Record\n          Byte 6: URI Prefix Code\n                  0x02 = https://www.\n          Bytes 7-18: URI (12 bytes)\n                  sparkfun.com\n  Byte 19: Type5 Tag TLV-Format: T (Type field)\n          0xFE = Terminator TLV\n*/\n</code></pre>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_08_NDEF_URI/#sfe_st25dv64kc_ndef-class","title":"SFE_ST25DV64KC_NDEF Class","text":"<p>To be able to use the extra NDEF methods, we need to use the <code>SFE_ST25DV64KC_NDEF</code> class, instead of <code>SFE_ST25DV64KC</code>:</p> <pre><code>  SFE_ST25DV64KC_NDEF tag;\n</code></pre> <p><code>SFE_ST25DV64KC_NDEF</code> inherits all of the <code>SFE_ST25DV64KC</code> methods, so we can do everything with a single <code>SFE_ST25DV64KC_NDEF</code> object.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_08_NDEF_URI/#writing-multiple-ndef-uri-records","title":"Writing multiple NDEF URI Records","text":"<p>If we want to write multiple records, we need to keep track of which address each URI is written to, so the URIs can be concatenated correctly.</p> <p>We also need to tell <code>writeNDEFURI</code> which is the first record (Message Begin = 1) and which is the last (Message End = 1).</p> <p>The code becomes:</p> <pre><code>  uint16_t memoryLocation = tag.getCCFileLen(); // Start writing at the memory location immediately after the CC File\n  tag.writeNDEFURI(\"sparkfun.com\", SFE_ST25DV_NDEF_URI_ID_CODE_HTTPS_WWW, &amp;memoryLocation, true, false); // Message Begin = 1, Message End = 0\n  tag.writeNDEFURI(\"github.com/sparkfun\", SFE_ST25DV_NDEF_URI_ID_CODE_HTTPS, &amp;memoryLocation, false, false); // Message Begin = 0, Message End = 0\n  tag.writeNDEFURI(\"twitter.com/sparkfun\", SFE_ST25DV_NDEF_URI_ID_CODE_HTTPS, &amp;memoryLocation, false, true); // Message Begin = 0, Message End = 1\n</code></pre> <p>Each time <code>writeNDEFURI</code> is called, it starts writing at <code>memoryLocation</code>. When the write is complete, <code>memoryLocation</code> is updated so that the next record is written starting at the next memory location.</p> <p>The three URIs written by the example are:</p> <ul> <li><code>https://www.sparkfun.com</code></li> <li><code>https://github.com/sparkfun</code></li> <li><code>https://twitter.com/sparkfun</code></li> </ul> <p>It is possible to write multiple URI, WiFi and Text records into a single tag.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_08_NDEF_URI/#reading-an-ndef-uri-record","title":"Reading an NDEF URI Record","text":"<p>There may be times when we want to read back a URI from the tag. E.g. if you have updated the tag using your smart phone and want to use the new URI in your Arduino code.</p> <p>The code to do this is:</p> <pre><code>  // Read back the third URI\n  char theURI[30];\n  Serial.println(F(\"Reading the third NDEF URI record:\"));\n  if (tag.readNDEFURI(theURI, 30, 3))\n    Serial.println(theURI);\n  else\n    Serial.println(F(\"Read failed!\"));\n</code></pre> <p><code>theURI</code> is a 30-byte char array which will hold the URI. It needs to be long enough to contain the whole URI, including the <code>https:///www.</code> prefix.</p> <p><code>readNDEFURI(theURI, 30, 3)</code> performs the read. The URI is written into <code>theURI</code>. The <code>30</code> tells <code>readNDEFURI</code> how many chars <code>theURI</code> can hold. If the URI is too long for <code>theURI</code>, <code>readNDEFURI</code> will return false. Finally, the <code>3</code> tells <code>readNDEFURI</code> to return the third URI from tag memory.</p> <p>To read the first URI, we could have called <code>readNDEFURI(theURI, 30)</code> as the URI defaults to 1.</p> <p>If we call <code>readNDEFURI(theURI, 30, 4)</code>, the result is false as the tag only contains three URIs. This is a trick we can use to determine how many URIs the tag contains.</p> <p>You can use \"NFC Tap\" to check the NDEF data.</p> <p></p> <p></p> <p>Just for fun, you can \"swipe left\" on a URI record in NFC Tap, change the URI, and then write it back to the tag. If you comment out the first part of the example, leaving only the <code>readNDEFURI</code>, you will be able to read the new URI.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_09_NDEF_WiFi/","title":"Example 9 - NDEF WiFi","text":"<p>An example showing how to create an NDEF WiFi record using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_09_NDEF_WiFi/#key-features","title":"Key Features","text":"<ul> <li>Writing the tag's Capability Container (CC)</li> <li>Writing an NDEF WiFi record</li> <li>Reading an NDEF WiFi record</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_09_NDEF_WiFi/#creating-an-ndef-wifi-record","title":"Creating an NDEF WiFi Record","text":"<p>A lot of information needs to be contained in an NDEF WiFi record, not simply the SSID and Password:</p> <pre><code>/*\n  To create a single NDEF WiFi short record:\n\n  00000 0x0000 E2 40 00 01 00 00 03 FF 03 72 DA 17 57 00 61 70 .@.......r..W.ap\n  00016 0x0010 70 6C 69 63 61 74 69 6F 6E 2F 76 6E 64 2E 77 66 plication/vnd.wf\n  00032 0x0020 61 2E 77 73 63 10 0E 00 53 10 26 00 01 01 10 45 a.wsc...S.&amp;....E\n  00048 0x0030 00 0C 67 75 65 73 74 4E 65 74 77 6F 72 6B 10 03 ..guestNetwork..\n  00064 0x0040 00 02 00 20 10 0F 00 02 00 08 10 27 00 10 67 75 ... .......'..gu\n  00080 0x0050 65 73 74 50 61 73 73 77 6F 72 64 31 32 33 10 20 estPassword123.\n  00096 0x0060 00 06 00 00 00 00 00 00 10 49 00 06 00 37 2A 02 .........I...7*.\n  00112 0x0070 01 01 10 49 00 06 00 37 2A 00 01 20 FE\n\n  Starting at memory location 0008:\n\n  Byte 0: Type5 Tag TLV-Format: T (Type field)\n          0x03 = NDEF Message TLV\n  Byte 1: Type5 Tag TLV-Format: L (Length field) (1-Byte Format)\n          0x72 = 114 Bytes\n  Bytes 2-115: Type5 Tag TLV-Format: V (Value field)\n          Byte 2: Record Header = 0xDA\n                  b7 = 0b1 MB (Message Begin)\n                  b6 = 0b1 ME (Message End)\n                  b5 = 0b0 CF (Chunk Flag)\n                  b4 = 0b1 SR (Short Record)\n                  b3 = 0b1 IL (ID Length)\n                  b2 b1 b0 = 0b010 TNF (Type Name Format): Media-type as defined in RFC 2046\n          Byte 3: Type Length\n                  0x17 = 23 Bytes\n          Byte 4: Payload Length\n                  0x57 = 87 Bytes\n          Byte 5: ID Length\n                  0x00 = 0 Bytes\n          Bytes 6-28: Type (23 bytes)\n                  \"application/vnd.wfa.wsc\"\n          Start of Payload:\n          Bytes 29+30: 0x100E (WiFi Credential)\n          Bytes 31+32: 0x00 0x53 (Length = 83)\n          Bytes 33+34: 0x1026 (Network Index)\n          Bytes 35+36: 0x00 0x01 (Length = 1)\n          Byte 37:     0x01 (Value 1 is used for backwards compatibility)\n          Bytes 38+39: 0x1045 (SSID)\n          Bytes 40+41: 0x00 0x0C (length = 12)\n          Bytes 42-53: \"guestNetwork\"\n          Bytes 54+55: 0x1003(Authentication Type)\n          Bytes 56+57: 0x00 0x02 (Length = 2)\n          Bytes 58+59: 0x00 0x20 (WPA2 Personal)\n          Bytes 60+61: 0x100F (Encryption Type)\n          Bytes 62+63: 0x00 0x02 (Length = 2)\n          Bytes 64+65: 0x00 0x08 (AES)\n          Bytes 66+67: 0x1027 (Network Key)\n          Bytes 68+69: 0x00 0x10 (Length = 16)\n          Bytes 70-85: \"guestPassword123\"\n          Bytes 86+87: 0x1020 (MAC Address)\n          Bytes 88+89: 0x00 0x06 (Length = 6)\n          Bytes 90-95: 0x00 0x00 0x00 0x00 0x00 0x00\n          Bytes 96+97: 0x1049 (Vendor Extension)\n          Bytes 98+99: 0x00 0x06 (Length = 6)\n          Bytes 100-102: 0x00 0x37 0x2A (Vendor ID)\n          Byte 103: 0x02 (Network Key Shareable)\n          Byte 104: 0x01 (Length)\n          Byte 105: 0x01 (True)\n          Bytes 106+107: 0x1049 (Vendor Extension)\n          Bytes 108+109: 0x00 0x06 (Length = 6)\n          Bytes 110-112: 0x00 0x37 0x2A (Vendor ID)\n          Byte 113: 0x00 (Version2)\n          Byte 114: 0x01 (Length)\n          Byte 115: 0x20 (Version 2.0)\n          End of Payload\n  Byte 116: Type5 Tag TLV-Format: T (Type field)\n          0xFE = Terminator TLV\n*/\n</code></pre> <p>Fortunately <code>writeNDEFWiFi</code> does all of the heavy lifting for you. Creating a WiFi record is as simple as:</p> <pre><code>  // Write a single NDEF WiFi record\n  Serial.println(F(\"Writing the NDEF WiFi record\"));\n  tag.writeNDEFWiFi(\"guestNetwork\", \"guestPassword123\");\n</code></pre> <p>Again, like <code>writeNDEFURI</code>, you can write multiple records if you wish:</p> <pre><code>  uint16_t memoryLocation = tag.getCCFileLen(); // Start writing at the memory location immediately after the CC File\n  tag.writeNDEFWiFi(\"guestNetwork\", \"guestPassword123\", &amp;memoryLocation, true, false); // Message Begin = 1, Message End = 0\n  tag.writeNDEFWiFi(\"guestNetwork2\", \"guestPassword456\", &amp;memoryLocation, false, true); // Message Begin = 0, Message End = 1\n</code></pre> <p>It is possible to write multiple URI, WiFi and Text records into a single tag.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_09_NDEF_WiFi/#reading-an-ndef-wifi-record","title":"Reading an NDEF WiFi Record","text":"<p>You are much more likely to want to read an NDEF WiFi record, having written it to the tag using your smart phone.</p> <p>Reading the record is as simple as:</p> <pre><code>  // Read the first NDEF WiFi record\n  char ssid[20]; // Create storage for the SSID\n  char passwd[20]; // Create storage for the password\n  Serial.println(F(\"Reading the first NDEF WiFi record:\"));\n  if (tag.readNDEFWiFi(ssid, 20, passwd, 20, 1)) // Read the first record. The '1' is optional\n  {\n    Serial.print(F(\"    SSID:\"));\n    Serial.println(ssid);\n    Serial.print(F(\"Password:\"));\n    Serial.println(passwd);\n  }\n  else\n    Serial.println(F(\"Read failed!\"));\n</code></pre> <p></p> <p></p> <p>Just for fun, you can \"swipe left\" on a WiFi record in NFC Tap, change the details, and then write it back to the tag. If you comment out the first part of the example, leaving only the <code>readNDEFWiFi</code>, you will be able to read the new details.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_10_NDEF_Text/","title":"Example 10 - NDEF Text","text":"<p>An example showing how to create an NDEF Text record using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_10_NDEF_Text/#key-features","title":"Key Features","text":"<ul> <li>Writing the tag's Capability Container (CC)</li> <li>Writing an NDEF Text record</li> <li>Reading an NDEF Text record</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_10_NDEF_Text/#creating-an-ndef-text-record","title":"Creating an NDEF Text Record","text":"<p>Only a small amount of extra information is needed to create an NDEF Text record. It is another \"Well-Known Type\":</p> <pre><code>/*\n  To create a NDEF Text record:\n\n  (See above for TLV formatting)\n\n  Byte 0: Record Header\n          b7 = MB (Message Begin)\n          b6 = ME (Message End)\n          b5 = CF (Chunk Flag)\n          b4 = SR (Short Record)\n          b3 = IL (ID Length)\n          b2 b1 b0 = 0b001 TNF (Type Name Format): NFC Forum Well-Known Type\n  Byte 3: Type Length\n          0x01 = 1 Byte\n  Byte(s) 4: Payload Length (1-Byte or 4-Byte format)\n  Byte n: Record Type\n          0x54 = \"T\" Text Record\n  Byte n+1: Text Data header\n          b7 = UTF 8/16 (0 = UTF 8 encoding)\n          b6 = reserved\n          b5-b0 = Language Code Length\n  Bytes n+2: Language Code (\"en\" = English)\n  Bytes n+2+LCL: Text Data\n*/\n</code></pre> <p>The code to create two text records is:</p> <pre><code>  // Write two NDEF UTF-8 Text records\n  uint16_t memLoc = tag.getCCFileLen();\n\n  Serial.println(F(\"Writing the first NDEF Text record\"));\n  tag.writeNDEFText(\"Hello, World!\", &amp;memLoc, true, false); // MB=1, ME=0\n\n  Serial.println(F(\"Writing the second NDEF Text record\"));\n  tag.writeNDEFText(\"All your base are belong to us\", &amp;memLoc, false, true); // MB=0, ME=1\n</code></pre> <p>It is possible to write multiple URI, WiFi and Text records into a single tag.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_10_NDEF_Text/#reading-an-ndef-text-record","title":"Reading an NDEF Text Record","text":"<p>Reading the text record is as simple as:</p> <pre><code>  // Read back the second NDEF UTF-8 Text record\n  Serial.println(F(\"Reading the second NDEF Text record:\"));\n  char theText[40];\n  if (tag.readNDEFText(theText, 40, 2))\n    Serial.println(theText);\n  else\n    Serial.println(F(\"Read failed!\"));\n</code></pre> <p></p> <p></p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_11_Memory_Leak_Test/","title":"Example 11 - Memory Leak Test","text":"<p>An example showing how to check for memory leaks using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_11_Memory_Leak_Test/#key-features","title":"Key Features","text":"<ul> <li>Checking for a memory leak by instantiating the tag object in the loop</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_11_Memory_Leak_Test/#memory-leak-test","title":"Memory Leak Test","text":"<p>Normally, the <code>SFE_ST25DV64KC_NDEF tag</code> object is instantiated once, at global scale, so that both <code>setup()</code> and <code>loop()</code> can access it.</p> <p>Example 11 instantiates the tag object inside <code>loop()</code> to check for possible memory leaks. The tag object is destructed and re-instantiated each time around the loop. If the library were not cleaning up the memory correctly, we would soon see out-of-memory errors on platforms with limited RAM - like the good old ATmega328P.</p> <p>Attention</p> <p>Do not leave this example running for a prolonged period. The tag EEPROM has a lifetime of 400000 to 1000000 write cycles - depending on temperature. This example could quickly burn through those!</p> <p>Attention</p> <p>The example writes multiple NDEF URI, WiFi and Text records. If you disconnect the power during a write, the memory may end up 'corrupted' and not able to be read with NFC Tap. Re-run one of the earlier examples to reset the memory if required.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_12_Production_Test/","title":"Example 12 - Production Test","text":"<p>The example we use at SparkFun to test the Qwiic Dynamic Tag.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_12_Production_Test/#key-features","title":"Key Features","text":"<ul> <li>Waits for a tag to be connected</li> <li>Writes a single URI <code>https://www.sparkfun.com</code></li> <li>Waits for the tag to be disconnected</li> <li>Rinse and repeat</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_13_Check_For_NDEF_Write/","title":"Example 13 - Check For NDEF Write","text":"<p>An example showing how to check if a new NDEF record has been written to the tag, using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_13_Check_For_NDEF_Write/#key-features","title":"Key Features","text":"<ul> <li>Writing the tag's Capability Container (CC)</li> <li>Writing an Empty NDEF Record</li> <li>Waiting for a key press - to say it is 'safe' to read the tag with I<sup>2</sup>C</li> <li>Checking for the writing of new URI, WiFi or Text records</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_13_Check_For_NDEF_Write/#interface-arbitration","title":"Interface Arbitration","text":"<p>The ST25DV tag has a clever \"interface arbitration\" feature. If an I<sup>2</sup>C transaction is in progress, RF transactions are 'blocked'. And vice versa.</p> <p>This is obviously a good thing! But there are some complications to be aware of. It looks like the ST \"NFC Tap\" App uses a read-modify-write approach when adding new records to tag memory. We think it does this using separate RF transactions or 'sessions'. The App gets very confused if the tag is busy servicing a new I<sup>2</sup>C transaction (memory read) when it tries to do the RF 'write' after the 'modify'...</p> <p>Note: this is not an issue with the tag itself. The tag is very robust. It is an issue of how the App - and this example - have been written.</p> <p>The simple solution is to only read the tag using I<sup>2</sup>C when you know it is 'safe' to do so. I.e. when you know there is no RF activity taking place. In this example, the user presses a key (sends a single Serial character) to indicate the tag should be read.</p> <p>The next example shows how to avoid most I<sup>2</sup>C and RF 'collisions' using the GPO pin.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_13_Check_For_NDEF_Write/#writing-an-empty-ndef-record","title":"Writing an Empty NDEF Record","text":"<p>After clearing the first 256 bytes of tag memory and writing the CC File, the code creates an empty NDEF record to keep the App happy.</p> <pre><code>/*\n  To create an empty NDEF record:\n\n  0x03 0x03 0xD0 0x00 0x00 0xFE\n\n  Byte 0: Type5 Tag TLV-Format: T (Type field)\n          0x03 = NDEF Message TLV\n  Byte 1: Type5 Tag TLV-Format: L (Length field) (1-Byte Format)\n          0x03 = 3 Bytes\n  Bytes 2-4: Type5 Tag TLV-Format: V (Value field)\n          Byte 2: Record Header = 0xD0\n                  b7 = 0b1 MB (Message Begin)\n                  b6 = 0b1 ME (Message End)\n                  b5 = 0b0 CF (Chunk Flag)\n                  b4 = 0b1 SR (Short Record)\n                  b3 = 0b0 IL (ID Length)\n                  b2 b1 b0 = 0b000 TNF (Type Name Format): Empty\n          Byte 3: Type Length\n                  0x00 = 0 Bytes\n          Byte 4: Payload Length\n                  0x00 = 0 bytes\n  Byte 5: Type5 Tag TLV-Format: T (Type field)\n          0xFE = Terminator TLV\n*/\n</code></pre> <p>The code to create the empty record is:</p> <pre><code>  // Add an empty record at the first memory location after the CC File\n  Serial.println(F(\"Writing an empty (zero-length) TLV Record\"));\n  uint16_t memoryLocation = tag.getCCFileLen(); // Write to the memory location immediately after the CC File\n  tag.writeNDEFEmpty(&amp;memoryLocation);\n</code></pre>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_13_Check_For_NDEF_Write/#checking-for-a-key-press","title":"Checking for a Key Press","text":"<p>You will have seen this code many times before. It is simple code which: empties the Serial RX buffer; and checks for the arrival of any new characters:</p> <pre><code>  while (Serial.available()) // Empty the Serial buffer\n    Serial.read();\n\n  Serial.println(F(\"Please press any key to check for new records\"));\n  Serial.println();\n\n  while (!Serial.available())\n    ; // Wait for the user to press a key (send any character)\n</code></pre>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_13_Check_For_NDEF_Write/#checking-for-new-ndef-records","title":"Checking for new NDEF Records","text":"<p>It is possible to write multiple URI, WiFi and Text records into a single tag and for the code to detect when each is written.</p> <p>The code uses three <code>static</code> counters to keep track of how many URI, WiFi and Text records have already been processed:</p> <pre><code>  static uint8_t uriRecord = 1; // Keep track of how many URIs have been read\n  static uint8_t wifiRecord = 1; // Keep track of how many WiFi records have been read\n  static uint8_t textRecord = 1; // Keep track of how many Text records have been read\n</code></pre> <p>By passing the appropriate counter into the <code>readNDEF</code> function, the code can ignore existing entries and only return <code>true</code> when a new entry is found:</p> <pre><code>  if (tag.readNDEFURI(thing1, 50, uriRecord))\n    {\n      Serial.println(F(\"URI Record Found!\"));\n      Serial.println(thing1);\n      uriRecord++; // Increase the count\n    }\n</code></pre> <p>The code reads all new records by performing all three <code>readNDEF</code> calls inside a <code>while</code> loop. <code>keepGoing</code> is set to <code>true</code> initially so the loop can be entered. Inside the loop, it is always set to <code>false</code> but is then set set back to <code>true</code> if any one <code>readNDEF</code> returns <code>true</code>. This way the code will stay in the <code>while</code> loop until all new records have been read and all three <code>readNDEF</code> methods have returned <code>false</code>.</p> <pre><code>  bool keepGoing = true;\n\n  while (keepGoing)\n  {\n    keepGoing = false;\n\n    // Check for a new NDEF URI record\n    if (tag.readNDEFURI(thing1, 50, uriRecord))\n    {\n      Serial.println(F(\"New URI Record Found:\"));\n      Serial.println(thing1);\n      Serial.println();\n      uriRecord++; // Increase the count\n      keepGoing = true;\n    }\n\n    // Check for a new NDEF WiFi record\n    if (tag.readNDEFWiFi(thing1, 50, thing2, 50, wifiRecord))\n    {\n      Serial.println(F(\"New WiFi Record Found:\"));\n      Serial.print(F(\"    SSID:\"));\n      Serial.println(thing1);\n      Serial.print(F(\"Password:\"));\n      Serial.println(thing2);\n      Serial.println();\n      wifiRecord++; // Increase the count\n      keepGoing = true;\n    }\n\n    // Check for a new NDEF Text record\n    if (tag.readNDEFText(thing1, 50, textRecord))\n    {\n      Serial.println(F(\"New Text Record Found:\"));\n      Serial.println(thing1);\n      Serial.println();\n      textRecord++; // Increase the count\n      keepGoing = true;\n    }\n  }\n</code></pre>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_14_Wait_For_NDEF_Write/","title":"Example 14 - Wait For NDEF Write","text":"<p>An example showing how to wait for a new NDEF record to be written to the tag, using the SparkFun ST25DV64KC Arduino Library.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_14_Wait_For_NDEF_Write/#key-features","title":"Key Features","text":"<ul> <li>Writing the tag's Capability Container (CC)</li> <li>Writing an Empty NDEF Record</li> <li>(Optionally) Configuring the GPO pin to indicate RF activity</li> <li>Checking for the writing of new URI, WiFi or Text records</li> </ul>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_14_Wait_For_NDEF_Write/#using-the-gpo-pin-to-indicate-rf-activity-and-delay-the-next-i2c-transaction","title":"Using the GPO pin to indicate RF activity - and delay the next I<sup>2</sup>C transaction","text":"<p>The ST25DV tag has a clever \"interface arbitration\" feature. If an I<sup>2</sup>C transaction is in progress, RF transactions are 'blocked'. And vice versa.</p> <p>This is obviously a good thing! But there are some complications to be aware of. It looks like the ST \"NFC Tap\" App uses a read-modify-write approach when adding new records to tag memory. We think it does this using separate RF transactions or 'sessions'. The App gets very confused if the tag is busy servicing a new I<sup>2</sup>C transaction (memory read) when it tries to do the RF 'write' after the 'modify'...</p> <p>Note: this is not an issue with the tag itself. The tag is very robust. It is an issue of how the App - and this example - have been written and interact.</p> <p>A work-around is to use the GPO pin to indicate when RF activity is taking place and to use that to delay the next I<sup>2</sup>C transaction for a few seconds.</p> <p>This feature is disabled by default. You can enable it by uncommenting this line:</p> <pre><code>//#define useGPOpin // Uncomment this line if you want to use the GPO pin to detect RF activity\n</code></pre> <p>With <code>useGPOpin</code> enabled, the GPO pin is configured to indicate an RF User session and/or RF Activity:</p> <pre><code>#ifdef useGPOpin\n\n  // The GPO registers can only be changed during an open security session\n  Serial.println(F(\"Opening I2C session with password.\"));\n  uint8_t password[8] = {0x0};\n  tag.openI2CSession(password);\n\n  Serial.print(F(\"I2C session is \"));\n  Serial.println(tag.isI2CSessionOpen() ? \"opened.\" : \"closed.\");\n\n  // -=-=-=-=-=-=-=-=-\n\n  Serial.println(F(\"Configuring GPO1 to indicate RF user &amp; activity.\"));\n  tag.setGPO1Bit(BIT_GPO1_RF_USER_EN, true);\n  tag.setGPO1Bit(BIT_GPO1_RF_ACTIVITY_EN, true);\n\n  Serial.println(F(\"Disabling other bits.\"));\n  tag.setGPO1Bit(BIT_GPO1_RF_INTERRUPT_EN, false);\n  tag.setGPO1Bit(BIT_GPO1_FIELD_CHANGE_EN, false);\n  tag.setGPO1Bit(BIT_GPO1_RF_PUT_MSG_EN, false);\n  tag.setGPO1Bit(BIT_GPO1_RF_GET_MSG_EN, false);\n  tag.setGPO1Bit(BIT_GPO1_RF_WRITE_EN, false);\n\n  // -=-=-=-=-=-=-=-=-\n\n  Serial.println(F(\"Enabling GPO_EN bit.\"));\n  tag.setGPO1Bit(BIT_GPO1_GPO_EN, true);\n\n#endif\n</code></pre> <p>A digital pin is used to read the status of the GPO pin. The GPO pin goes low during RF activity and the code uses that to reset a timer. Reading the tag's EEPROM memory - to see if a new record has been added - is delayed for at least two seconds from the last RF activity. This gives the App time to complete its read-modify-write once it has started.</p> <pre><code>#ifdef useGPOpin\n  static unsigned long lastActivity = 0; // Keep track of the last RF activity\n\n  if (digitalRead(GPO_PIN) == LOW) // GPO will be low when there is RF activity\n  {\n    lastActivity = millis(); // Record the last RF activity\n  }\n\n  // Only try to communicate with the tag when there has been no RF activity for at least two seconds\n  if (millis() &gt; (lastActivity + 2000))\n#endif\n</code></pre> <p>This prevents most App confusion. You may still see occasions where the App thinks there is no NDEF record present. But this only happens when a new RF transaction is attempted while the tag is already performing an I<sup>2</sup>C transaction (memory read). Once the RF read-modify-write is underway, the two second timer prevents the next I<sup>2</sup>C transaction from interfering with it.</p> <p>It also helps a lot if you bring your phone near the tag first and then press the \"Write to Tag\" button. Bringing your phone near the tag generates a field which causes the tag to go into RF mode early. This locks out I<sup>2</sup>C, ahead of you pushing the button to start the actual RF write.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_14_Wait_For_NDEF_Write/#writing-an-empty-ndef-record","title":"Writing an Empty NDEF Record","text":"<p>Please see the previous example for details.</p>"},{"location":"sparkfun-st25dv64kc-arduino-library-examples/ex_14_Wait_For_NDEF_Write/#checking-for-new-ndef-records","title":"Checking for new NDEF Records","text":"<p>Please see the previous example for details.</p>"}]}